================================================================================
           LoRaPlat 嵌入式通信架构规格说明书 (Architecture V3.0)
================================================================================

[1. 核心设计哲学]
--------------------------------------------------------------------------------
1. 依赖倒置 (Dependency Inversion): 
   上层定义接口，底层实现接口。逻辑层 (Manager/Service) 绝不依赖硬件层 (Port) 的具体实现，
   只依赖抽象的 `GetTick`、`WriteData` 等接口。

2. 零阻塞 (Non-Blocking):
   全系统禁止使用 `HAL_Delay` 或 `while` 死循环等待。
   所有耗时操作（如 AT 指令交互、ACK 等待）必须通过 **状态机 (FSM)** 分片执行。

3. 职责单一 (SRP):
   每层只做一件事。Service 不管重传，Manager 不管 AT 指令，Core 不管 GPIO。

4. 插件化网络 (Pluggable Networking):
   基础点对点通信由 Service 保障；高级组网功能由 Net 组件扩展，Net 组件可裁剪。

[2. 协议帧结构定义 (Layer 3 负责组包/解包)]
--------------------------------------------------------------------------------
物理帧格式 (Total Overhead: 13 Bytes):
[Head:2] [Len:1] [Ctrl:1] [Seq:1] [TgtID:2] [SrcID:2] [Payload:N] [CRC:2] [Tail:2]

1. Head:    0x43 0x4D ('C', 'M')
2. Len:     Payload长度 (不含头尾和开销，仅数据部分)
3. Ctrl:    控制字
            - Bit[7]: 0=数据帧, 1=ACK帧
            - Bit[6]: 0=无需ACK, 1=需要ACK
            - Bit[5]: 0=无CRC, 1=含CRC16
            - Bit[0-4]: 保留
4. Seq:     包序号 (0-255)，用于ACK匹配和去重
5. TgtID:   目标设备ID (2字节，软件地址过滤用)
            - 0x0000: 未分配设备
            - 0xFFFF: 广播
            - GroupID: 组播 (V2.2 新增)
            - NetID: 单播
6. SrcID:   源设备ID (2字节)
7. Payload: 业务数据 (JSON等)
8. CRC:     CRC16校验值 (仅当Ctrl.Bit5=1时存在，否则占位或省略)
9. Tail:    0x0D 0x0A ('\r', '\n')

[3. 分层架构详解]
--------------------------------------------------------------------------------

Layer 5: App (应用层)
[文件]: main.c / user_app.c
[职责]: 
  - 纯粹的业务逻辑 (如: "收到指令开灯", "定时上报温湿度")。
  - 注册 Service 层的回调函数。
  - 决定是否启用 Net 层功能。
[边界]: 不直接调用 Manager 或 Core，只通过 Service 暴露的 API 交互。

Layer 4: Service (服务层) —— "系统管家"
[文件]: lora_service.c / .h
[职责]: 
  - **配置管理**: 负责 Flash 参数的读写 (ID, Channel, Power)。
  - **指令分流**: 识别并拦截 `CMD:` 开头的平台指令 (如 BIND, GROUP)，透传业务数据。
  - **事件分发**: 将底层的协议事件 (ACK, RX, ERR) 转换为业务事件通知 App。
  - **原子发送**: 提供最基础的 `Send(data, target)` 接口。
[边界]: 向下调用 Manager；向旁侧支持 Net；向上提供 API。

Layer 3.5: Net (网络层/插件) —— "交通指挥" (Optional)
[文件]: lora_net.c / .h
[职责]: 
  - **并发控制**: 实现 CSMA/CA 或 时隙 (Time-Slot) 算法，解决多设备冲突。
  - **路由中继**: (未来) 实现多跳传输。
  - **网络维护**: 处理信标 (Beacon)、时间同步。
[边界]: 依赖 Service 提供的原子发送能力；拦截 Service 的接收回调以处理网络包。

Layer 3: Manager (协议层) —— "可靠性保障"
[文件]: lora_manager.c / .h
[职责]: 
  - **私有协议栈**: 封包 (Head+Payload+CRC) 与 解包。
  - **可靠传输**: 实现 ACK 确认机制、超时重传逻辑、序列号 (Seq) 管理。
  - **流量控制**: 维护 **TX RingBuffer (发送队列)**，平滑突发流量。
  - **数据完整性**: 维护 **RX DoubleBuffer (双缓冲)**，防止接收覆盖。
  - **地址过滤**: 匹配 NetID (单播)、GroupID (组播)、0xFFFF (广播)。
[边界]: 纯逻辑层，不触碰硬件 IO，通过 Core 接口操作模块。

Layer 2: Core (驱动中间件) —— "翻译官"
[文件]: mod_lora.c / .h
[职责]: 
  - **AT 状态机**: 将阻塞式的 AT 指令交互重构为异步状态机 (Async FSM)。
  - **模式切换**: 控制 MD0 引脚切换透传/配置模式。
  - **硬件适配**: 将通用的操作翻译为特定模组 (ATK-LORA-01) 的指令。
[边界]: 向上提供抽象的 `SetMode`, `WriteRaw` 接口；向下调用 Port。

Layer 1: Port (硬件抽象层) —— "躯体"
[文件]: lora_port.c / .h
[职责]: 
  - **硬件隔离**: 唯一包含 `stm32f10x.h` 的层级。
  - **IO 操作**: GPIO 控制 (AUX, MD0), UART 收发。
  - **DMA 管理**: 维护 DMA 循环接收缓冲区。
  - **时基提供**: 提供毫秒级 `GetTick`。
  - **低功耗**: (未来) 管理 EXTI 中断唤醒与 Sleep 模式。
[边界]: 向所有上层提供统一的硬件操作接口。

[4. 数据流向示例]
--------------------------------------------------------------------------------
[发送流程]:
App (调用 Send) 
  -> Service (检查是否是 CMD, 封装 Meta) 
    -> Net (计算时隙, 避让冲突) 
      -> Manager (入队 TX Queue, 状态机取出, 加包头/CRC) 
        -> Core (检查 AUX 忙闲) 
          -> Port (DMA 写入 UART) 
            -> 物理空口

[接收流程]:
物理空口 
  -> Port (DMA 搬运到 RAM) 
    -> Manager (从 DMA 取出, 校验 CRC, 回复 ACK, 过滤地址) 
      -> Service (判断是 CMD 还是 Data) 
        -> Net (如果是路由包则拦截) 
          -> App (触发 OnRecvData 回调)

[5. 关键演进路线 (Roadmap)]
--------------------------------------------------------------------------------
Phase 1: 去阻塞化 (De-blocking)
  - 移除 Core/Manager 中所有 `Delay_ms`。
  - 实现 Core 层异步 AT 指令引擎。

Phase 2: 缓冲与队列 (Buffering)
  - Manager 层实现 TX RingBuffer (解决高频发送丢包)。
  - Manager 层实现 RX Ping-Pong Buffer (解决解析竞态)。

Phase 3: 低功耗基建 (Low Power Base)
  - Port 层引入 EXTI (AUX 中断)。
  - 引入 EventFlags 事件中心，替代纯轮询。

Phase 4: 网络插件 (Net Plugin)
  - 实现基于 ID 的时隙算法。
  - 实现简单的冲突退避机制。

================================================================================
