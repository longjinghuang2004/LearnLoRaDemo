## Directory Structure for `xyy的项目`

```
- xyy的项目/
    - function/
        - cJSON.c
        - cJSON.h
        - InputParser.c
        - InputParser.h
    - Hardware/
        - Flash.c
        - Flash.h
        - Key.c
        - Key.h
        - LED.c
        - LED.h
        - OLED.c
        - OLED.h
        - Serial.c
        - Serial.h
        - Timer.c
        - Timer.h
    - Listings
    - Model/
        - Algorithm.c
        - Algorithm.h
        - Indicator.c
        - Indicator.h
        - Model.c
        - Model.h
    - System/
        - Delay.c
        - Delay.h
    - User/
        - main.c
    - keilkill.bat
    - 项目描述.md
```


---

## File Contents

<project_files>
<file path="function\cJSON.c">
```c
/*
  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

/* cJSON */
/* JSON parser in C. */

/* disable warnings about old C89 functions in MSVC */
#if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
#define _CRT_SECURE_NO_DEPRECATE
#endif

#ifdef __GNUC__
#pragma GCC visibility push(default)
#endif
#if defined(_MSC_VER)
#pragma warning (push)
/* disable warning about single line comments in system headers */
#pragma warning (disable : 4001)
#endif

#include <string.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <float.h>

#ifdef ENABLE_LOCALES
#include <locale.h>
#endif

#if defined(_MSC_VER)
#pragma warning (pop)
#endif
#ifdef __GNUC__
#pragma GCC visibility pop
#endif

#include "cJSON.h"

/* define our own boolean type */
#ifdef true
#undef true
#endif
#define true ((cJSON_bool)1)

#ifdef false
#undef false
#endif
#define false ((cJSON_bool)0)

/* define isnan and isinf for ANSI C, if in C99 or above, isnan and isinf has been defined in math.h */
#ifndef isinf
#define isinf(d) (isnan((d - d)) && !isnan(d))
#endif
#ifndef isnan
#define isnan(d) (d != d)
#endif

#ifndef NAN
#ifdef _WIN32
#define NAN sqrt(-1.0)
#else
#define NAN 0.0/0.0
#endif
#endif

typedef struct {
    const unsigned char *json;
    size_t position;
} error;
static error global_error = { NULL, 0 };

CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
{
    return (const char*) (global_error.json + global_error.position);
}

CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item)
{
    if (!cJSON_IsString(item))
    {
        return NULL;
    }

    return item->valuestring;
}

CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item)
{
    if (!cJSON_IsNumber(item))
    {
        return (double) NAN;
    }

    return item->valuedouble;
}

/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 19)
    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
#endif

CJSON_PUBLIC(const char*) cJSON_Version(void)
{
    static char version[15];
    sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);

    return version;
}

/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
{
    if ((string1 == NULL) || (string2 == NULL))
    {
        return 1;
    }

    if (string1 == string2)
    {
        return 0;
    }

    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
    {
        if (*string1 == '\0')
        {
            return 0;
        }
    }

    return tolower(*string1) - tolower(*string2);
}

typedef struct internal_hooks
{
    void *(CJSON_CDECL *allocate)(size_t size);
    void (CJSON_CDECL *deallocate)(void *pointer);
    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
} internal_hooks;

#if defined(_MSC_VER)
/* work around MSVC error C2322: '...' address of dllimport '...' is not static */
static void * CJSON_CDECL internal_malloc(size_t size)
{
    return malloc(size);
}
static void CJSON_CDECL internal_free(void *pointer)
{
    free(pointer);
}
static void * CJSON_CDECL internal_realloc(void *pointer, size_t size)
{
    return realloc(pointer, size);
}
#else
#define internal_malloc malloc
#define internal_free free
#define internal_realloc realloc
#endif

/* strlen of character literals resolved at compile time */
#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(""))

static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };

static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
{
    size_t length = 0;
    unsigned char *copy = NULL;

    if (string == NULL)
    {
        return NULL;
    }

    length = strlen((const char*)string) + sizeof("");
    copy = (unsigned char*)hooks->allocate(length);
    if (copy == NULL)
    {
        return NULL;
    }
    memcpy(copy, string, length);

    return copy;
}

CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
{
    if (hooks == NULL)
    {
        /* Reset hooks */
        global_hooks.allocate = malloc;
        global_hooks.deallocate = free;
        global_hooks.reallocate = realloc;
        return;
    }

    global_hooks.allocate = malloc;
    if (hooks->malloc_fn != NULL)
    {
        global_hooks.allocate = hooks->malloc_fn;
    }

    global_hooks.deallocate = free;
    if (hooks->free_fn != NULL)
    {
        global_hooks.deallocate = hooks->free_fn;
    }

    /* use realloc only if both free and malloc are used */
    global_hooks.reallocate = NULL;
    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
    {
        global_hooks.reallocate = realloc;
    }
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
{
    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
    if (node)
    {
        memset(node, '\0', sizeof(cJSON));
    }

    return node;
}

/* Delete a cJSON structure. */
CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
{
    cJSON *next = NULL;
    while (item != NULL)
    {
        next = item->next;
        if (!(item->type & cJSON_IsReference) && (item->child != NULL))
        {
            cJSON_Delete(item->child);
        }
        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
        {
            global_hooks.deallocate(item->valuestring);
            item->valuestring = NULL;
        }
        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
        {
            global_hooks.deallocate(item->string);
            item->string = NULL;
        }
        global_hooks.deallocate(item);
        item = next;
    }
}

/* get the decimal point character of the current locale */
static unsigned char get_decimal_point(void)
{
#ifdef ENABLE_LOCALES
    struct lconv *lconv = localeconv();
    return (unsigned char) lconv->decimal_point[0];
#else
    return '.';
#endif
}

typedef struct
{
    const unsigned char *content;
    size_t length;
    size_t offset;
    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */
    internal_hooks hooks;
} parse_buffer;

/* check if the given size is left to read in a given parse buffer (starting with 1) */
#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
/* check if the buffer can be accessed at the given index (starting with 0) */
#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
#define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))
/* get a pointer to the buffer at the position */
#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)

/* Parse the input text to generate a number, and populate the result into item. */
static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
{
    double number = 0;
    unsigned char *after_end = NULL;
    unsigned char *number_c_string;
    unsigned char decimal_point = get_decimal_point();
    size_t i = 0;
    size_t number_string_length = 0;
    cJSON_bool has_decimal_point = false;

    if ((input_buffer == NULL) || (input_buffer->content == NULL))
    {
        return false;
    }

    /* copy the number into a temporary buffer and replace '.' with the decimal point
     * of the current locale (for strtod)
     * This also takes care of '\0' not necessarily being available for marking the end of the input */
    for (i = 0; can_access_at_index(input_buffer, i); i++)
    {
        switch (buffer_at_offset(input_buffer)[i])
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case '+':
            case '-':
            case 'e':
            case 'E':
                number_string_length++;
                break;

            case '.':
                number_string_length++;
                has_decimal_point = true;
                break;

            default:
                goto loop_end;
        }
    }
loop_end:
    /* malloc for temporary buffer, add 1 for '\0' */
    number_c_string = (unsigned char *) input_buffer->hooks.allocate(number_string_length + 1);
    if (number_c_string == NULL)
    {
        return false; /* allocation failure */
    }

    memcpy(number_c_string, buffer_at_offset(input_buffer), number_string_length);
    number_c_string[number_string_length] = '\0';

    if (has_decimal_point)
    {
        for (i = 0; i < number_string_length; i++)
        {
            if (number_c_string[i] == '.')
            {
                /* replace '.' with the decimal point of the current locale (for strtod) */
                number_c_string[i] = decimal_point;
            }
        }
    }

    number = strtod((const char*)number_c_string, (char**)&after_end);
    if (number_c_string == after_end)
    {
        /* free the temporary buffer */
        input_buffer->hooks.deallocate(number_c_string);
        return false; /* parse_error */
    }

    item->valuedouble = number;

    /* use saturation in case of overflow */
    if (number >= INT_MAX)
    {
        item->valueint = INT_MAX;
    }
    else if (number <= (double)INT_MIN)
    {
        item->valueint = INT_MIN;
    }
    else
    {
        item->valueint = (int)number;
    }

    item->type = cJSON_Number;

    input_buffer->offset += (size_t)(after_end - number_c_string);
    /* free the temporary buffer */
    input_buffer->hooks.deallocate(number_c_string);
    return true;
}

/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
{
    if (number >= INT_MAX)
    {
        object->valueint = INT_MAX;
    }
    else if (number <= (double)INT_MIN)
    {
        object->valueint = INT_MIN;
    }
    else
    {
        object->valueint = (int)number;
    }

    return object->valuedouble = number;
}

/* Note: when passing a NULL valuestring, cJSON_SetValuestring treats this as an error and return NULL */
CJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring)
{
    char *copy = NULL;
    size_t v1_len;
    size_t v2_len;
    /* if object's type is not cJSON_String or is cJSON_IsReference, it should not set valuestring */
    if ((object == NULL) || !(object->type & cJSON_String) || (object->type & cJSON_IsReference))
    {
        return NULL;
    }
    /* return NULL if the object is corrupted or valuestring is NULL */
    if (object->valuestring == NULL || valuestring == NULL)
    {
        return NULL;
    }

    v1_len = strlen(valuestring);
    v2_len = strlen(object->valuestring);

    if (v1_len <= v2_len)
    {
        /* strcpy does not handle overlapping string: [X1, X2] [Y1, Y2] => X2 < Y1 or Y2 < X1 */
        if (!( valuestring + v1_len < object->valuestring || object->valuestring + v2_len < valuestring ))
        {
            return NULL;
        }
        strcpy(object->valuestring, valuestring);
        return object->valuestring;
    }
    copy = (char*) cJSON_strdup((const unsigned char*)valuestring, &global_hooks);
    if (copy == NULL)
    {
        return NULL;
    }
    if (object->valuestring != NULL)
    {
        cJSON_free(object->valuestring);
    }
    object->valuestring = copy;

    return copy;
}

typedef struct
{
    unsigned char *buffer;
    size_t length;
    size_t offset;
    size_t depth; /* current nesting depth (for formatted printing) */
    cJSON_bool noalloc;
    cJSON_bool format; /* is this print a formatted print */
    internal_hooks hooks;
} printbuffer;

/* realloc printbuffer if necessary to have at least "needed" bytes more */
static unsigned char* ensure(printbuffer * const p, size_t needed)
{
    unsigned char *newbuffer = NULL;
    size_t newsize = 0;

    if ((p == NULL) || (p->buffer == NULL))
    {
        return NULL;
    }

    if ((p->length > 0) && (p->offset >= p->length))
    {
        /* make sure that offset is valid */
        return NULL;
    }

    if (needed > INT_MAX)
    {
        /* sizes bigger than INT_MAX are currently not supported */
        return NULL;
    }

    needed += p->offset + 1;
    if (needed <= p->length)
    {
        return p->buffer + p->offset;
    }

    if (p->noalloc) {
        return NULL;
    }

    /* calculate new buffer size */
    if (needed > (INT_MAX / 2))
    {
        /* overflow of int, use INT_MAX if possible */
        if (needed <= INT_MAX)
        {
            newsize = INT_MAX;
        }
        else
        {
            return NULL;
        }
    }
    else
    {
        newsize = needed * 2;
    }

    if (p->hooks.reallocate != NULL)
    {
        /* reallocate with realloc if available */
        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
        if (newbuffer == NULL)
        {
            p->hooks.deallocate(p->buffer);
            p->length = 0;
            p->buffer = NULL;

            return NULL;
        }
    }
    else
    {
        /* otherwise reallocate manually */
        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
        if (!newbuffer)
        {
            p->hooks.deallocate(p->buffer);
            p->length = 0;
            p->buffer = NULL;

            return NULL;
        }

        memcpy(newbuffer, p->buffer, p->offset + 1);
        p->hooks.deallocate(p->buffer);
    }
    p->length = newsize;
    p->buffer = newbuffer;

    return newbuffer + p->offset;
}

/* calculate the new length of the string in a printbuffer and update the offset */
static void update_offset(printbuffer * const buffer)
{
    const unsigned char *buffer_pointer = NULL;
    if ((buffer == NULL) || (buffer->buffer == NULL))
    {
        return;
    }
    buffer_pointer = buffer->buffer + buffer->offset;

    buffer->offset += strlen((const char*)buffer_pointer);
}

/* securely comparison of floating-point variables */
static cJSON_bool compare_double(double a, double b)
{
    double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);
    return (fabs(a - b) <= maxVal * DBL_EPSILON);
}

/* Render the number nicely from the given item into a string. */
static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
{
    unsigned char *output_pointer = NULL;
    double d = item->valuedouble;
    int length = 0;
    size_t i = 0;
    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */
    unsigned char decimal_point = get_decimal_point();
    double test = 0.0;

    if (output_buffer == NULL)
    {
        return false;
    }

    /* This checks for NaN and Infinity */
    if (isnan(d) || isinf(d))
    {
        length = sprintf((char*)number_buffer, "null");
    }
    else if(d == (double)item->valueint)
    {
        length = sprintf((char*)number_buffer, "%d", item->valueint);
    }
    else
    {
        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
        length = sprintf((char*)number_buffer, "%1.15g", d);

        /* Check whether the original double can be recovered */
        if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || !compare_double((double)test, d))
        {
            /* If not, print with 17 decimal places of precision */
            length = sprintf((char*)number_buffer, "%1.17g", d);
        }
    }

    /* sprintf failed or buffer overrun occurred */
    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
    {
        return false;
    }

    /* reserve appropriate space in the output */
    output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
    if (output_pointer == NULL)
    {
        return false;
    }

    /* copy the printed number to the output and replace locale
     * dependent decimal point with '.' */
    for (i = 0; i < ((size_t)length); i++)
    {
        if (number_buffer[i] == decimal_point)
        {
            output_pointer[i] = '.';
            continue;
        }

        output_pointer[i] = number_buffer[i];
    }
    output_pointer[i] = '\0';

    output_buffer->offset += (size_t)length;

    return true;
}

/* parse 4 digit hexadecimal number */
static unsigned parse_hex4(const unsigned char * const input)
{
    unsigned int h = 0;
    size_t i = 0;

    for (i = 0; i < 4; i++)
    {
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
        {
            h += (unsigned int) input[i] - '0';
        }
        else if ((input[i] >= 'A') && (input[i] <= 'F'))
        {
            h += (unsigned int) 10 + input[i] - 'A';
        }
        else if ((input[i] >= 'a') && (input[i] <= 'f'))
        {
            h += (unsigned int) 10 + input[i] - 'a';
        }
        else /* invalid */
        {
            return 0;
        }

        if (i < 3)
        {
            /* shift left to make place for the next nibble */
            h = h << 4;
        }
    }

    return h;
}

/* converts a UTF-16 literal to UTF-8
 * A literal can be one or two sequences of the form \uXXXX */
static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
{
    long unsigned int codepoint = 0;
    unsigned int first_code = 0;
    const unsigned char *first_sequence = input_pointer;
    unsigned char utf8_length = 0;
    unsigned char utf8_position = 0;
    unsigned char sequence_length = 0;
    unsigned char first_byte_mark = 0;

    if ((input_end - first_sequence) < 6)
    {
        /* input ends unexpectedly */
        goto fail;
    }

    /* get the first utf16 sequence */
    first_code = parse_hex4(first_sequence + 2);

    /* check that the code is valid */
    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
    {
        goto fail;
    }

    /* UTF16 surrogate pair */
    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
    {
        const unsigned char *second_sequence = first_sequence + 6;
        unsigned int second_code = 0;
        sequence_length = 12; /* \uXXXX\uXXXX */

        if ((input_end - second_sequence) < 6)
        {
            /* input ends unexpectedly */
            goto fail;
        }

        if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
        {
            /* missing second half of the surrogate pair */
            goto fail;
        }

        /* get the second utf16 sequence */
        second_code = parse_hex4(second_sequence + 2);
        /* check that the code is valid */
        i
```
</file>
<file path="function\cJSON.h">
```h
/*
  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

#ifndef cJSON__h
#define cJSON__h

#ifdef __cplusplus
extern "C"
{
#endif

#if !defined(__WINDOWS__) && (defined(WIN32) || defined(WIN64) || defined(_MSC_VER) || defined(_WIN32))
#define __WINDOWS__
#endif

#ifdef __WINDOWS__

/* When compiling for windows, we specify a specific calling convention to avoid issues where we are being called from a project with a different default calling convention.  For windows you have 3 define options:

CJSON_HIDE_SYMBOLS - Define this in the case where you don't want to ever dllexport symbols
CJSON_EXPORT_SYMBOLS - Define this on library build when you want to dllexport symbols (default)
CJSON_IMPORT_SYMBOLS - Define this if you want to dllimport symbol

For *nix builds that support visibility attribute, you can define similar behavior by

setting default visibility to hidden by adding
-fvisibility=hidden (for gcc)
or
-xldscope=hidden (for sun cc)
to CFLAGS

then using the CJSON_API_VISIBILITY flag to "export" the same symbols the way CJSON_EXPORT_SYMBOLS does

*/

#define CJSON_CDECL __cdecl
#define CJSON_STDCALL __stdcall

/* export symbols by default, this is necessary for copy pasting the C and header file */
#if !defined(CJSON_HIDE_SYMBOLS) && !defined(CJSON_IMPORT_SYMBOLS) && !defined(CJSON_EXPORT_SYMBOLS)
#define CJSON_EXPORT_SYMBOLS
#endif

#if defined(CJSON_HIDE_SYMBOLS)
#define CJSON_PUBLIC(type)   type CJSON_STDCALL
#elif defined(CJSON_EXPORT_SYMBOLS)
#define CJSON_PUBLIC(type)   __declspec(dllexport) type CJSON_STDCALL
#elif defined(CJSON_IMPORT_SYMBOLS)
#define CJSON_PUBLIC(type)   __declspec(dllimport) type CJSON_STDCALL
#endif
#else /* !__WINDOWS__ */
#define CJSON_CDECL
#define CJSON_STDCALL

#if (defined(__GNUC__) || defined(__SUNPRO_CC) || defined (__SUNPRO_C)) && defined(CJSON_API_VISIBILITY)
#define CJSON_PUBLIC(type)   __attribute__((visibility("default"))) type
#else
#define CJSON_PUBLIC(type) type
#endif
#endif

/* project version */
#define CJSON_VERSION_MAJOR 1
#define CJSON_VERSION_MINOR 7
#define CJSON_VERSION_PATCH 19

#include <stddef.h>

/* cJSON Types: */
#define cJSON_Invalid (0)
#define cJSON_False  (1 << 0)
#define cJSON_True   (1 << 1)
#define cJSON_NULL   (1 << 2)
#define cJSON_Number (1 << 3)
#define cJSON_String (1 << 4)
#define cJSON_Array  (1 << 5)
#define cJSON_Object (1 << 6)
#define cJSON_Raw    (1 << 7) /* raw json */

#define cJSON_IsReference 256
#define cJSON_StringIsConst 512

/* The cJSON structure: */
typedef struct cJSON
{
    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
    struct cJSON *next;
    struct cJSON *prev;
    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
    struct cJSON *child;

    /* The type of the item, as above. */
    int type;

    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */
    char *valuestring;
    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */
    int valueint;
    /* The item's number, if type==cJSON_Number */
    double valuedouble;

    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
    char *string;
} cJSON;

typedef struct cJSON_Hooks
{
      /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */
      void *(CJSON_CDECL *malloc_fn)(size_t sz);
      void (CJSON_CDECL *free_fn)(void *ptr);
} cJSON_Hooks;

typedef int cJSON_bool;

/* Limits how deeply nested arrays/objects can be before cJSON rejects to parse them.
 * This is to prevent stack overflows. */
#ifndef CJSON_NESTING_LIMIT
#define CJSON_NESTING_LIMIT 1000
#endif

/* Limits the length of circular references can be before cJSON rejects to parse them.
 * This is to prevent stack overflows. */
#ifndef CJSON_CIRCULAR_LIMIT
#define CJSON_CIRCULAR_LIMIT 10000
#endif

/* returns the version of cJSON as a string */
CJSON_PUBLIC(const char*) cJSON_Version(void);

/* Supply malloc, realloc and free functions to cJSON */
CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);

/* Memory Management: the caller is always responsible to free the results from all variants of cJSON_Parse (with cJSON_Delete) and cJSON_Print (with stdlib free, cJSON_Hooks.free_fn, or cJSON_free as appropriate). The exception is cJSON_PrintPreallocated, where the caller has full responsibility of the buffer. */
/* Supply a block of JSON, and this returns a cJSON object you can interrogate. */
CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);
CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length);
/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error so will match cJSON_GetErrorPtr(). */
CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);
CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated);

/* Render a cJSON entity to text for transfer/storage. */
CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);
/* Render a cJSON entity to text for transfer/storage without any formatting. */
CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);
/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */
CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt);
/* Render a cJSON entity to text using a buffer already allocated in memory with given length. Returns 1 on success and 0 on failure. */
/* NOTE: cJSON is not always 100% accurate in estimating how much memory it will use, so to be safe allocate 5 bytes more than you actually need */
CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format);
/* Delete a cJSON entity and all subentities. */
CJSON_PUBLIC(void) cJSON_Delete(cJSON *item);

/* Returns the number of items in an array (or object). */
CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);
/* Retrieve item number "index" from array "array". Returns NULL if unsuccessful. */
CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);
/* Get item "string" from object. Case insensitive. */
CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);
CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);
CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string);
/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void);

/* Check item type and return its value */
CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item);
CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item);

/* These functions check the type of an item */
CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item);

/* These calls create a cJSON item of the appropriate type. */
CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);
CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);
CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);
/* raw json */
CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw);
CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);

/* Create a string where valuestring references a string so
 * it will not be freed by cJSON_Delete */
CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string);
/* Create an object/array that only references it's elements so
 * they will not be freed by cJSON_Delete */
CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child);
CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child);

/* These utilities create an Array of count items.
 * The parameter count cannot be greater than the number of elements in the number array, otherwise array access will be out of bounds.*/
CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);
CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);
CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);
CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count);

/* Append item to the specified array/object. */
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item);
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);
/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object.
 * WARNING: When this function was used, make sure to always check that (item->type & cJSON_StringIsConst) is zero before
 * writing to `item->string` */
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item);
/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item);

/* Remove/Detach items from Arrays/Objects. */
CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);
CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which);
CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which);
CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string);
CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);
CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string);
CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);

/* Update array items. */
CJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem); /* Shifts pre-existing items to the right. */
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem);
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);

/* Duplicate a cJSON item */
CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);
/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
 * need to be released. With recurse!=0, it will duplicate any children connected to the item.
 * The item->next and ->prev pointers are always zero on return from Duplicate. */
/* Recursively compare two cJSON items for equality. If either a or b is NULL or invalid, they will be considered unequal.
 * case_sensitive determines if object keys are treated case sensitive (1) or case insensitive (0) */
CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);

/* Minify a strings, remove blank characters(such as ' ', '\t', '\r', '\n') from strings.
 * The input pointer json cannot point to a read-only address area, such as a string constant, 
 * but should point to a readable and writable address area. */
CJSON_PUBLIC(void) cJSON_Minify(char *json);

/* Helper functions for creating and adding items to an object at the same time.
 * They return the added item or NULL on failure. */
CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name);
CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name);
CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name);
CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);
CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);
CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);
CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);
CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name);
CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name);

/* When assigning an integer value, it needs to be propagated to valuedouble too. */
#define cJSON_SetIntValue(object, number) ((object) ? (object)->valueint = (object)->valuedouble = (number) : (number))
/* helper for the cJSON_SetNumberValue macro */
CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number);
#define cJSON_SetNumberValue(object, number) ((object != NULL) ? cJSON_SetNumberHelper(object, (double)number) : (number))
/* Change the valuestring of a cJSON_String object, only takes effect when type of object is cJSON_String */
CJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring);

/* If the object is not a boolean type this does nothing and returns cJSON_Invalid else it returns the new type*/
#define cJSON_SetBoolValue(object, boolValue) ( \
    (object != NULL && ((object)->type & (cJSON_False|cJSON_True))) ? \
    (object)->type=((object)->type &(~(cJSON_False|cJSON_True)))|((boolValue)?cJSON_True:cJSON_False) : \
    cJSON_Invalid\
)

/* Macro for iterating over an array or object */
#define cJSON_ArrayForEach(element, array) for(element = (array != NULL) ? (array)->child : NULL; element != NULL; element = element->next)

/* malloc/free objects using the malloc/free functions that have been set with cJSON_InitHooks */
CJSON_PUBLIC(void *) cJSON_malloc(size_t size);
CJSON_PUBLIC(void) cJSON_free(void *object);

#ifdef __cplusplus
}
#endif

#endif

```
</file>
<file path="function\InputParser.c">
```c
#include "InputParser.h"
#include <string.h>
#include <stdio.h>

/**
  * @brief  (内部函数) 解析一个包含min和max成员的JSON对象
  */
static int parse_min_max_object(const cJSON *json_object, MinMaxFloat *output_struct)
{
    if (!cJSON_IsObject(json_object)) return 0;

    cJSON *min_item = cJSON_GetObjectItem(json_object, "min");
    cJSON *max_item = cJSON_GetObjectItem(json_object, "max");

    if (cJSON_IsNumber(min_item) && cJSON_IsNumber(max_item)) {
        output_struct->min = (float)min_item->valuedouble;
        output_struct->max = (float)max_item->valuedouble;
        return 1;
    }
    return 0;
}

/**
  * @brief  [新函数] 解析输入的"data"类型分包JSON字符串
  */
int Parse_BatchFrame(const char *json_string, BatchFrame *output_frame)
{
    cJSON *root = NULL;
    cJSON *item = NULL;
    cJSON *payload_obj = NULL;
    int success = 1;

    memset(output_frame, 0, sizeof(BatchFrame));

    root = cJSON_Parse(json_string);
    if (root == NULL) {
        printf("Error: Failed to parse JSON string.\r\n");
        return 0;
    }

    // 1. 解析 batch_id
    item = cJSON_GetObjectItem(root, "batch_id");
    if (cJSON_IsString(item)) {
        strncpy(output_frame->batch_id, item->valuestring, BATCH_ID_MAX_LEN - 1);
    } else { success = 0; }

    // 2. 解析 station_id
    if (success) {
        item = cJSON_GetObjectItem(root, "station_id");
        if (cJSON_IsString(item)) {
            strncpy(output_frame->station_id, item->valuestring, STATION_ID_MAX_LEN - 1);
        } else { success = 0; }
    }

    // 3. 解析 frame_index
    if (success) {
        item = cJSON_GetObjectItem(root, "frame_index");
        if (cJSON_IsNumber(item)) {
            output_frame->frame_index = item->valueint;
        } else { success = 0; }
    }

    // 4. 解析 total_frames
    if (success) {
        item = cJSON_GetObjectItem(root, "total_frames");
        if (cJSON_IsNumber(item)) {
            output_frame->total_frames = item->valueint;
        } else { success = 0; }
    }

    // 5. 解析 payload 对象
    if (success) {
        payload_obj = cJSON_GetObjectItem(root, "payload");
        if (cJSON_IsObject(payload_obj)) {
            // 5.1 解析 timestamp
            item = cJSON_GetObjectItem(payload_obj, "timestamp");
            if (cJSON_IsString(item)) {
                strncpy(output_frame->payload.timestamp, item->valuestring, TIMESTAMP_MAX_LEN - 1);
            } else { success = 0; }

            // 5.2 解析 wave_height
            if (success) {
                cJSON *wave_obj = cJSON_GetObjectItem(payload_obj, "wave_height");
                if (!parse_min_max_object(wave_obj, &output_frame->payload.wave_height)) { success = 0; }
            }

            // 5.3 解析 water_level
            if (success) {
                cJSON *water_obj = cJSON_GetObjectItem(payload_obj, "water_level");
                if (!parse_min_max_object(water_obj, &output_frame->payload.water_level)) { success = 0; }
            }
        } else {
            success = 0; // payload 对象不存在或类型错误
        }
    }
    
    if (!success) {
        printf("Error: Failed parsing batch frame JSON. Check format.\r\n");
    }

    cJSON_Delete(root);
    return success;
}

```
</file>
<file path="function\InputParser.h">
```h
#ifndef __INPUT_PARSER_H
#define __INPUT_PARSER_H

#include "cJSON.h"

// --- 常量定义 ---
#define STATION_ID_MAX_LEN      16
#define BATCH_ID_MAX_LEN        32
#define TIMESTAMP_MAX_LEN       20
// [修改] 根据新的需求（7-24个时间节点），将最大帧数调整为24
#define MAX_FRAMES_PER_BATCH    24

// --- 数据结构定义 ---

/**
 * @brief 存储min/max浮点数值对
 */
typedef struct {
    float min;
    float max;
} MinMaxFloat;

/**
 * @brief 存储单个时间点上的所有预报数据 (即JSON中的payload)
 */
typedef struct {
    char timestamp[TIMESTAMP_MAX_LEN];
    MinMaxFloat wave_height;
    MinMaxFloat water_level;
} TimeSeriesData;

/**
 * @brief [新结构] 存储从单个分包JSON解析出的元数据和负载
 */
typedef struct {
    char batch_id[BATCH_ID_MAX_LEN];
    char station_id[STATION_ID_MAX_LEN];
    int frame_index;
    int total_frames;
    TimeSeriesData payload;
} BatchFrame;


/**
 * @brief [结构用途改变] 现在用于存储一个完整批次的所有数据
 */
typedef struct {
    char station_id[STATION_ID_MAX_LEN];
    TimeSeriesData time_series[MAX_FRAMES_PER_BATCH];
    int time_series_count;
} ForecastInput;


// --- 函数原型声明 ---

/**
  * @brief  [新函数] 解析输入的"data"类型分包JSON字符串
  */
int Parse_BatchFrame(const char *json_string, BatchFrame *output_frame);

#endif // __INPUT_PARSER_H

```
</file>
<file path="Hardware\Flash.c">
```c
#include "Flash.h"
#include <string.h> // 用于 memcpy

/**
  * @brief  读取指定地址的一个字节 (8-bit)
  * @param  Address 要读取的地址
  * @retval 读取到的字节数据
  */
uint8_t Flash_ReadByte(uint32_t Address)
{
    // Flash是内存映射的，可以直接通过指针读取
    // 使用 volatile 防止编译器优化
    return *(volatile uint8_t*)Address;
}

/**
  * @brief  读取指定地址的一个字 (32-bit)
  * @param  Address 要读取的地址
  * @retval 读取到的字数据
  */
uint32_t Flash_ReadWord(uint32_t Address)
{
    return *(volatile uint32_t*)Address;
}

/**
  * @brief  擦除指定的Flash页面
  * @param  PageAddress 要擦除页面的任一地址
  * @retval 无
  */
void Flash_ErasePage(uint32_t PageAddress)
{
    FLASH_Unlock();                     // 解锁Flash
    FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR); // 清除所有标志位
    FLASH_ErasePage(PageAddress);       // 擦除页面
    FLASH_Lock();                       // 锁定Flash
}

/**
  * @brief  在指定地址写入一个字 (32-bit)
  * @param  Address 写入地址，必须是4的倍数
  * @param  Data 要写入的32位数据
  * @retval 无
  */
void Flash_ProgramWord(uint32_t Address, uint32_t Data)
{
    FLASH_Unlock();
    FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
    FLASH_ProgramWord(Address, Data);
    FLASH_Lock();
}

/**
  * @brief  从Flash读取整个模型参数结构体
  * @param  params 指向要填充的RAM结构体变量
  * @note   由于Flash是内存映射的，直接使用memcpy是最高效、最安全的方式。
  */
void Flash_ReadModelParams(RiskModelParameters* params)
{
    memcpy(params, (void*)FLASH_STORE_ADDR, sizeof(RiskModelParameters));
}

/**
  * @brief  将整个模型参数结构体写入Flash
  * @param  params 指向包含待写入数据的RAM结构体变量
  * @note   此函数使用32位字写入，并能正确处理结构体大小不是4字节整数倍的情况。
  */
void Flash_WriteModelParams(const RiskModelParameters* params)
{
    // 1. 擦除页面
    Flash_ErasePage(FLASH_STORE_ADDR);
    
    // 2. 计算需要写入的32位字的数量和剩余字节数
    uint32_t size_in_words = sizeof(RiskModelParameters) / 4;
    uint8_t remainder_bytes = sizeof(RiskModelParameters) % 4;
    
    // 3. 将结构体指针转换为 uint32_t 指针，用于按字访问
    uint32_t* pData = (uint32_t*)params;
    
    // 4. 循环写入所有完整的字
    for (uint32_t i = 0; i < size_in_words; i++)
    {
        Flash_ProgramWord(FLASH_STORE_ADDR + i * 4, pData[i]);
    }
    
    // 5. 如果有剩余的字节 (1, 2, 或 3)，则特殊处理
    if (remainder_bytes > 0)
    {
        // 计算剩余字节的起始地址
        uint32_t remainder_addr = FLASH_STORE_ADDR + size_in_words * 4;
        uint8_t* remainder_data_ptr = (uint8_t*)params + size_in_words * 4;
        
        // 创建一个临时的32位变量，并用Flash的擦除值(0xFF)填充
        uint32_t last_word = 0xFFFFFFFF;
        
        // 使用memcpy将剩余的字节复制到临时变量的低位
        memcpy(&last_word, remainder_data_ptr, remainder_bytes);
        
        // 将这个包含剩余字节的字写入Flash
        Flash_ProgramWord(remainder_addr, last_word);
    }
}

```
</file>
<file path="Hardware\Flash.h">
```h
#ifndef __FLASH_H
#define __FLASH_H

#include "stm32f10x.h"
#include "Model.h" // 引入Model.h以识别RiskModelParameters类型

// 定义参数存储区的起始地址 (Flash最后一页)
#define FLASH_STORE_ADDR    0x0800FC00

/* --- 底层基础函数 --- */
uint8_t Flash_ReadByte(uint32_t Address);
uint32_t Flash_ReadWord(uint32_t Address);
void Flash_ErasePage(uint32_t PageAddress);
void Flash_ProgramWord(uint32_t Address, uint32_t Data);

/* --- 高层应用函数 --- */
void Flash_ReadModelParams(RiskModelParameters* params);
void Flash_WriteModelParams(const RiskModelParameters* params);

#endif

```
</file>
<file path="Hardware\Key.c">
```c
#include "stm32f10x.h"                  // Device header
#include "Delay.h"

/**
  * 函    数：按键初始化
  * 参    数：无
  * 返 回 值：无
  */
void Key_Init(void)
{
	/*开启时钟*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);		//开启GPIOB的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);						//将PB1和PB11引脚初始化为上拉输入
}

/**
  * 函    数：按键获取键码
  * 参    数：无
  * 返 回 值：按下按键的键码值，范围：0~2，返回0代表没有按键按下
  * 注意事项：此函数是阻塞式操作，当按键按住不放时，函数会卡住，直到按键松手
  */
uint8_t Key_GetNum(void)
{
	uint8_t KeyNum = 0;		//定义变量，默认键码值为0
	
	if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)			//读PB1输入寄存器的状态，如果为0，则代表按键1按下
	{
		Delay_ms(20);											//延时消抖
		while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0);	//等待按键松手
		Delay_ms(20);											//延时消抖
		KeyNum = 1;												//置键码为1
	}
	
	if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0)			//读PB11输入寄存器的状态，如果为0，则代表按键2按下
	{
		Delay_ms(20);											//延时消抖
		while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0);	//等待按键松手
		Delay_ms(20);											//延时消抖
		KeyNum = 2;												//置键码为2
	}
	
	return KeyNum;			//返回键码值，如果没有按键按下，所有if都不成立，则键码为默认值0
}

```
</file>
<file path="Hardware\Key.h">
```h
#ifndef __KEY_H
#define __KEY_H

void Key_Init(void);
uint8_t Key_GetNum(void);

#endif

```
</file>
<file path="Hardware\LED.c">
```c
#include "stm32f10x.h"                  // Device header

/**
  * 函    数：LED初始化
  * 参    数：无
  * 返 回 值：无
  */
void LED_Init(void)
{
	/*开启时钟*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);		//开启GPIOA的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);						//将PA1和PA2引脚初始化为推挽输出
	
	/*设置GPIO初始化后的默认电平*/
	GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);				//设置PA1和PA2引脚为高电平
}

/**
  * 函    数：LED1开启
  * 参    数：无
  * 返 回 值：无
  */
void LED1_ON(void)
{
	GPIO_ResetBits(GPIOA, GPIO_Pin_1);		//设置PA1引脚为低电平
}

/**
  * 函    数：LED1关闭
  * 参    数：无
  * 返 回 值：无
  */
void LED1_OFF(void)
{
	GPIO_SetBits(GPIOA, GPIO_Pin_1);		//设置PA1引脚为高电平
}

/**
  * 函    数：LED1状态翻转
  * 参    数：无
  * 返 回 值：无
  */
void LED1_Turn(void)
{
	if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == 0)		//获取输出寄存器的状态，如果当前引脚输出低电平
	{
		GPIO_SetBits(GPIOA, GPIO_Pin_1);					//则设置PA1引脚为高电平
	}
	else													//否则，即当前引脚输出高电平
	{
		GPIO_ResetBits(GPIOA, GPIO_Pin_1);					//则设置PA1引脚为低电平
	}
}

/**
  * 函    数：LED2开启
  * 参    数：无
  * 返 回 值：无
  */
void LED2_ON(void)
{
	GPIO_ResetBits(GPIOA, GPIO_Pin_2);		//设置PA2引脚为低电平
}

/**
  * 函    数：LED2关闭
  * 参    数：无
  * 返 回 值：无
  */
void LED2_OFF(void)
{
	GPIO_SetBits(GPIOA, GPIO_Pin_2);		//设置PA2引脚为高电平
}

/**
  * 函    数：LED2状态翻转
  * 参    数：无
  * 返 回 值：无
  */
void LED2_Turn(void)
{
	if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2) == 0)		//获取输出寄存器的状态，如果当前引脚输出低电平
	{                                                  
		GPIO_SetBits(GPIOA, GPIO_Pin_2);               		//则设置PA2引脚为高电平
	}                                                  
	else                                               		//否则，即当前引脚输出高电平
	{                                                  
		GPIO_ResetBits(GPIOA, GPIO_Pin_2);             		//则设置PA2引脚为低电平
	}
}

```
</file>
<file path="Hardware\LED.h">
```h
#ifndef __LED_H
#define __LED_H

void LED_Init(void);
void LED1_ON(void);
void LED1_OFF(void);
void LED1_Turn(void);
void LED2_ON(void);
void LED2_OFF(void);
void LED2_Turn(void);

#endif

```
</file>
<file path="Hardware\OLED.c">
```c
#include "stm32f10x.h"
#include "OLED_Font.h"

/*引脚配置*/
#define OLED_W_SCL(x)		GPIO_WriteBit(GPIOB, GPIO_Pin_8, (BitAction)(x))
#define OLED_W_SDA(x)		GPIO_WriteBit(GPIOB, GPIO_Pin_9, (BitAction)(x))

/*引脚初始化*/
void OLED_I2C_Init(void)
{
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStructure;
 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
 	GPIO_Init(GPIOB, &GPIO_InitStructure);
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 	GPIO_Init(GPIOB, &GPIO_InitStructure);
	
	OLED_W_SCL(1);
	OLED_W_SDA(1);
}

/**
  * @brief  I2C开始
  * @param  无
  * @retval 无
  */
void OLED_I2C_Start(void)
{
	OLED_W_SDA(1);
	OLED_W_SCL(1);
	OLED_W_SDA(0);
	OLED_W_SCL(0);
}

/**
  * @brief  I2C停止
  * @param  无
  * @retval 无
  */
void OLED_I2C_Stop(void)
{
	OLED_W_SDA(0);
	OLED_W_SCL(1);
	OLED_W_SDA(1);
}

/**
  * @brief  I2C发送一个字节
  * @param  Byte 要发送的一个字节
  * @retval 无
  */
void OLED_I2C_SendByte(uint8_t Byte)
{
	uint8_t i;
	for (i = 0; i < 8; i++)
	{
		OLED_W_SDA(!!(Byte & (0x80 >> i)));
		OLED_W_SCL(1);
		OLED_W_SCL(0);
	}
	OLED_W_SCL(1);	//额外的一个时钟，不处理应答信号
	OLED_W_SCL(0);
}

/**
  * @brief  OLED写命令
  * @param  Command 要写入的命令
  * @retval 无
  */
void OLED_WriteCommand(uint8_t Command)
{
	OLED_I2C_Start();
	OLED_I2C_SendByte(0x78);		//从机地址
	OLED_I2C_SendByte(0x00);		//写命令
	OLED_I2C_SendByte(Command); 
	OLED_I2C_Stop();
}

/**
  * @brief  OLED写数据
  * @param  Data 要写入的数据
  * @retval 无
  */
void OLED_WriteData(uint8_t Data)
{
	OLED_I2C_Start();
	OLED_I2C_SendByte(0x78);		//从机地址
	OLED_I2C_SendByte(0x40);		//写数据
	OLED_I2C_SendByte(Data);
	OLED_I2C_Stop();
}

/**
  * @brief  OLED设置光标位置
  * @param  Y 以左上角为原点，向下方向的坐标，范围：0~7
  * @param  X 以左上角为原点，向右方向的坐标，范围：0~127
  * @retval 无
  */
void OLED_SetCursor(uint8_t Y, uint8_t X)
{
	OLED_WriteCommand(0xB0 | Y);					//设置Y位置
	OLED_WriteCommand(0x10 | ((X & 0xF0) >> 4));	//设置X位置高4位
	OLED_WriteCommand(0x00 | (X & 0x0F));			//设置X位置低4位
}

/**
  * @brief  OLED清屏
  * @param  无
  * @retval 无
  */
void OLED_Clear(void)
{  
	uint8_t i, j;
	for (j = 0; j < 8; j++)
	{
		OLED_SetCursor(j, 0);
		for(i = 0; i < 128; i++)
		{
			OLED_WriteData(0x00);
		}
	}
}

/**
  * @brief  OLED显示一个字符
  * @param  Line 行位置，范围：1~4
  * @param  Column 列位置，范围：1~16
  * @param  Char 要显示的一个字符，范围：ASCII可见字符
  * @retval 无
  */
void OLED_ShowChar(uint8_t Line, uint8_t Column, char Char)
{      	
	uint8_t i;
	OLED_SetCursor((Line - 1) * 2, (Column - 1) * 8);		//设置光标位置在上半部分
	for (i = 0; i < 8; i++)
	{
		OLED_WriteData(OLED_F8x16[Char - ' '][i]);			//显示上半部分内容
	}
	OLED_SetCursor((Line - 1) * 2 + 1, (Column - 1) * 8);	//设置光标位置在下半部分
	for (i = 0; i < 8; i++)
	{
		OLED_WriteData(OLED_F8x16[Char - ' '][i + 8]);		//显示下半部分内容
	}
}

/**
  * @brief  OLED显示字符串
  * @param  Line 起始行位置，范围：1~4
  * @param  Column 起始列位置，范围：1~16
  * @param  String 要显示的字符串，范围：ASCII可见字符
  * @retval 无
  */
void OLED_ShowString(uint8_t Line, uint8_t Column, char *String)
{
	uint8_t i;
	for (i = 0; String[i] != '\0'; i++)
	{
		OLED_ShowChar(Line, Column + i, String[i]);
	}
}

/**
  * @brief  OLED次方函数
  * @retval 返回值等于X的Y次方
  */
uint32_t OLED_Pow(uint32_t X, uint32_t Y)
{
	uint32_t Result = 1;
	while (Y--)
	{
		Result *= X;
	}
	return Result;
}

/**
  * @brief  OLED显示数字（十进制，正数）
  * @param  Line 起始行位置，范围：1~4
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~4294967295
  * @param  Length 要显示数字的长度，范围：1~10
  * @retval 无
  */
void OLED_ShowNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length)
{
	uint8_t i;
	for (i = 0; i < Length; i++)							
	{
		OLED_ShowChar(Line, Column + i, Number / OLED_Pow(10, Length - i - 1) % 10 + '0');
	}
}

/**
  * @brief  OLED显示数字（十进制，带符号数）
  * @param  Line 起始行位置，范围：1~4
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：-2147483648~2147483647
  * @param  Length 要显示数字的长度，范围：1~10
  * @retval 无
  */
void OLED_ShowSignedNum(uint8_t Line, uint8_t Column, int32_t Number, uint8_t Length)
{
	uint8_t i;
	uint32_t Number1;
	if (Number >= 0)
	{
		OLED_ShowChar(Line, Column, '+');
		Number1 = Number;
	}
	else
	{
		OLED_ShowChar(Line, Column, '-');
		Number1 = -Number;
	}
	for (i = 0; i < Length; i++)							
	{
		OLED_ShowChar(Line, Column + i + 1, Number1 / OLED_Pow(10, Length - i - 1) % 10 + '0');
	}
}

/**
  * @brief  OLED显示数字（十六进制，正数）
  * @param  Line 起始行位置，范围：1~4
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~0xFFFFFFFF
  * @param  Length 要显示数字的长度，范围：1~8
  * @retval 无
  */
void OLED_ShowHexNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length)
{
	uint8_t i, SingleNumber;
	for (i = 0; i < Length; i++)							
	{
		SingleNumber = Number / OLED_Pow(16, Length - i - 1) % 16;
		if (SingleNumber < 10)
		{
			OLED_ShowChar(Line, Column + i, SingleNumber + '0');
		}
		else
		{
			OLED_ShowChar(Line, Column + i, SingleNumber - 10 + 'A');
		}
	}
}

/**
  * @brief  OLED显示数字（二进制，正数）
  * @param  Line 起始行位置，范围：1~4
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~1111 1111 1111 1111
  * @param  Length 要显示数字的长度，范围：1~16
  * @retval 无
  */
void OLED_ShowBinNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length)
{
	uint8_t i;
	for (i = 0; i < Length; i++)							
	{
		OLED_ShowChar(Line, Column + i, Number / OLED_Pow(2, Length - i - 1) % 2 + '0');
	}
}

/**
  * @brief  OLED初始化
  * @param  无
  * @retval 无
  */
void OLED_Init(void)
{
	uint32_t i, j;
	
	for (i = 0; i < 1000; i++)			//上电延时
	{
		for (j = 0; j < 1000; j++);
	}
	
	OLED_I2C_Init();			//端口初始化
	
	OLED_WriteCommand(0xAE);	//关闭显示
	
	OLED_WriteCommand(0xD5);	//设置显示时钟分频比/振荡器频率
	OLED_WriteCommand(0x80);
	
	OLED_WriteCommand(0xA8);	//设置多路复用率
	OLED_WriteCommand(0x3F);
	
	OLED_WriteCommand(0xD3);	//设置显示偏移
	OLED_WriteCommand(0x00);
	
	OLED_WriteCommand(0x40);	//设置显示开始行
	
	OLED_WriteCommand(0xA1);	//设置左右方向，0xA1正常 0xA0左右反置
	
	OLED_WriteCommand(0xC8);	//设置上下方向，0xC8正常 0xC0上下反置

	OLED_WriteCommand(0xDA);	//设置COM引脚硬件配置
	OLED_WriteCommand(0x12);
	
	OLED_WriteCommand(0x81);	//设置对比度控制
	OLED_WriteCommand(0xCF);

	OLED_WriteCommand(0xD9);	//设置预充电周期
	OLED_WriteCommand(0xF1);

	OLED_WriteCommand(0xDB);	//设置VCOMH取消选择级别
	OLED_WriteCommand(0x30);

	OLED_WriteCommand(0xA4);	//设置整个显示打开/关闭

	OLED_WriteCommand(0xA6);	//设置正常/倒转显示

	OLED_WriteCommand(0x8D);	//设置充电泵
	OLED_WriteCommand(0x14);

	OLED_WriteCommand(0xAF);	//开启显示
		
	OLED_Clear();				//OLED清屏
}

```
</file>
<file path="Hardware\OLED.h">
```h
#ifndef __OLED_H
#define __OLED_H

void OLED_Init(void);
void OLED_Clear(void);
void OLED_ShowChar(uint8_t Line, uint8_t Column, char Char);
void OLED_ShowString(uint8_t Line, uint8_t Column, char *String);
void OLED_ShowNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length);
void OLED_ShowSignedNum(uint8_t Line, uint8_t Column, int32_t Number, uint8_t Length);
void OLED_ShowHexNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length);
void OLED_ShowBinNum(uint8_t Line, uint8_t Column, uint32_t Number, uint8_t Length);

#endif

```
</file>
<file path="Hardware\Serial.c">
```c
#include "Serial.h"
#include "stm32f10x.h"
#include <stdio.h>
// #include <stdarg.h> // 不再需要，因为 vsprintf 已被移除

// --- 全局变量定义 ---
char Serial_RxPacket[SERIAL_RX_BUFFER_SIZE];
uint8_t Serial_RxFlag;

/**
  * 函    数：串口初始化
  * (此函数无变化)
  */
void Serial_Init(void)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	
	USART_InitTypeDef USART_InitStructure;
	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_Init(USART1, &USART_InitStructure);
	
	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
	
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_Init(&NVIC_InitStructure);
	
	USART_Cmd(USART1, ENABLE);
}

/**
  * 函    数：串口发送一个字节
  * (此函数无变化)
  */
void Serial_SendByte(uint8_t Byte)
{
	USART_SendData(USART1, Byte);
	while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
}

/**
  * 函    数：串口发送一个字符串
  * (此函数无变化)
  */
void Serial_SendString(char *String)
{
	for (uint16_t i = 0; String[i] != '\0'; i++)
	{
		Serial_SendByte(String[i]);
	}
}

// ... 其他基础发送函数 (SendArray, SendNumber) 保持不变 ...

/**
  * 函    数：重定向C语言标准库的printf到底层串口发送函数
  * 参    数：ch - 要打印的字符
  * 参    数：f - 文件流指针 (未使用)
  * 返 回 值：返回写入的字符
  * 说    明：这是实现标准printf()的关键。标准库的printf会逐个字符
  *           调用本函数，本函数再通过Serial_SendByte将字符发送出去。
  *           这种“流式”处理方式内存效率极高，且没有缓冲区大小限制。
  */
int fputc(int ch, FILE *f)
{
	Serial_SendByte(ch);
	return ch;
}

/*
 * 自定义的 printf 函数已被完全移除。
 * 它存在严重的堆栈溢出风险且效率低下。
 * 请在所有代码中直接使用标准库的 printf() 函数。
 */

/**
  * 函    数：USART1中断函数
  * (此函数无变化，保持上一版修复后的状态)
  */
void USART1_IRQHandler(void)
{
	static uint16_t pRxPacket = 0;
	static uint8_t RxState = 0;
	
	if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)
	{
		uint8_t RxData = USART_ReceiveData(USART1);
		
		if (RxState == 0)
		{
			if (RxData == '\r')
			{
				RxState = 1;
			}
			else
			{
				Serial_RxPacket[pRxPacket] = RxData;
				pRxPacket++;
                if (pRxPacket >= (SERIAL_RX_BUFFER_SIZE - 1))
                {
                    pRxPacket = SERIAL_RX_BUFFER_SIZE - 1;
                }
			}
		}
		else if (RxState == 1)
		{
			if (RxData == '\n')
			{
				RxState = 0;
				Serial_RxPacket[pRxPacket] = '\0';
				Serial_RxFlag = 1;
				pRxPacket = 0;
			}
			else
			{
				RxState = 0;
                if (pRxPacket < (SERIAL_RX_BUFFER_SIZE - 1)) {
                    Serial_RxPacket[pRxPacket++] = '\r';
                }
                if (pRxPacket < (SERIAL_RX_BUFFER_SIZE - 1)) {
                    Serial_RxPacket[pRxPacket++] = RxData;
                }
			}
		}
		
		USART_ClearITPendingBit(USART1, USART_IT_RXNE);
	}
}

```
</file>
<file path="Hardware\Serial.h">
```h
#ifndef __SERIAL_H
#define __SERIAL_H

#include <stdio.h>
#include <stdint.h> // [修复] 包含此头文件以定义 uint8_t, uint16_t 等类型

// --- 缓冲区大小宏定义 ---
#define SERIAL_RX_BUFFER_SIZE 1024

// --- 全局变量声明 ---
extern char Serial_RxPacket[];
extern uint8_t Serial_RxFlag;

// --- [修正] 使用正确的宏定义来替换 Serial_Printf ---
// 这将确保所有地方的调用都指向正确的、内存安全的标准 printf
#define Serial_Printf printf

// --- 函数原型声明 ---
void Serial_Init(void);
void Serial_SendByte(uint8_t Byte);
void Serial_SendArray(uint8_t *Array, uint16_t Length);
void Serial_SendString(char *String);
void Serial_SendNumber(uint32_t Number, uint8_t Length);

#endif

```
</file>
<file path="Hardware\Timer.c">
```c
#include "stm32f10x.h"
#include "LED.h"

// 声明一个来自main.c的全局超时标志
extern volatile uint8_t g_TimeoutFlag;


/******************************************************************************/
/*                                TIM2 for LED                                */
/******************************************************************************/

// Timer_Init, Timer_SetBlinkFreq, TIM2_IRQHandler 函数保持不变
void Timer_Init(void)
{
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
    
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 1000 - 1;
    TIM_TimeBaseInitStructure.TIM_Prescaler = 7200 - 1;
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure);
    
    TIM_ClearFlag(TIM2, TIM_FLAG_Update);
    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);
    
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_Init(&NVIC_InitStructure);
    
    TIM_Cmd(TIM2, ENABLE);
}

void Timer_SetBlinkFreq(uint8_t Freq_Hz)
{
    if (Freq_Hz == 0) return;
    uint16_t arr_value = (10000 / (2 * Freq_Hz)) - 1;
    TIM_SetAutoreload(TIM2, arr_value);
    TIM_SetCounter(TIM2, 0);
}

void TIM2_IRQHandler(void)
{
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    {
        LED1_Turn();
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
    }
}


/******************************************************************************/
/*                         TIM3 for Reception Timeout                         */
/******************************************************************************/

/**
  * @brief  [最终修正] 初始化TIM3作为5秒超时定时器
  * @note   假定TIM3时钟为72MHz。
  *         PSC = 7200 - 1  => 计数频率 = 72MHz / 7200 = 10kHz (0.1ms/tick)
  *         ARR = 50000 - 1 => 中断周期 = 50000 * 0.1ms = 5000ms = 5s
  */
void Timeout_Timer_Init(void)
{
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period = 50000 - 1;   // 50,000 ticks
    TIM_TimeBaseInitStructure.TIM_Prescaler = 7200 - 1;   // 10kHz tick frequency
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);
    
    TIM_ClearFlag(TIM3, TIM_FLAG_Update);
    TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);
    
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
    NVIC_Init(&NVIC_InitStructure);
}

// Timeout_Timer_Start, Stop, Reset, TIM3_IRQHandler 函数保持不变
void Timeout_Timer_Start(void)
{
    TIM_SetCounter(TIM3, 0);
    TIM_Cmd(TIM3, ENABLE);
}

void Timeout_Timer_Stop(void)
{
    TIM_Cmd(TIM3, DISABLE);
}

void Timeout_Timer_Reset(void)
{
    TIM_SetCounter(TIM3, 0);
}

void TIM3_IRQHandler(void)
{
    if (TIM_GetITStatus(TIM3, TIM_IT_Update) == SET)
    {
        Timeout_Timer_Stop();
        g_TimeoutFlag = 1;
        TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    }
}

```
</file>
<file path="Hardware\Timer.h">
```h
#ifndef __TIMER_H
#define __TIMER_H

#include "stm32f10x.h" // 引入头文件以识别 uint8_t 等

/* --- TIM2 for LED Blinking --- */
void Timer_Init(void);
void Timer_SetBlinkFreq(uint8_t Freq_Hz);


/* --- TIM3 for Packet Reception Timeout --- */
void Timeout_Timer_Init(void);
void Timeout_Timer_Start(void);
void Timeout_Timer_Stop(void);
void Timeout_Timer_Reset(void);


#endif

```
</file>
<file path="Model\Algorithm.c">
```c
#include "Algorithm.h"
#include <string.h> // for memset
#include <math.h>   // for expf (float version of exp)

/**
  * @brief  (内部函数) 将一个值限制在指定的min和max之间
  */
static float clamp(float value, float min_val, float max_val) {
    if (value < min_val) return min_val;
    if (value > max_val) return max_val;
    return value;
}

/**
  * @brief  (内部函数) 使用Sigmoid函数对输入值进行归一化处理
  *         将 value 从 [L, U] 的范围非线性地映射到 [0, 1]
  */
static float sigmoid_normalize(float value, float L, float U) {
    if (U - L == 0) return 0.5f; // 防止除以零，返回中间值
    
    float p = (value - L) / (U - L);
    // 使用 expf 是因为我们的所有计算都是基于 float 的，效率更高
    float result = 1.0f / (1.0f + expf(-10.0f * p + 5.0f));
    
    return result;
}

/**
  * @brief  根据输入的预报数据和模型参数，计算所有时间点的风险指数
  */
void Algorithm_CalculateAllRisks(const ForecastInput* input, const RiskModelParameters* params, RiskResult* results_array)
{
    memset(results_array, 0, sizeof(RiskResult) * input->time_series_count);

    for (int i = 0; i < input->time_series_count; i++)
    {
        const TimeSeriesData* current_data = &input->time_series[i];

        // 1. 数据归一化
        float norm_wh_min = sigmoid_normalize(current_data->wave_height.min, params->norm_wave_height_L, params->norm_wave_height_U);
        float norm_wh_max = sigmoid_normalize(current_data->wave_height.max, params->norm_wave_height_L, params->norm_wave_height_U);
        float norm_wl_min = sigmoid_normalize(current_data->water_level.min, params->norm_water_level_L, params->norm_water_level_U);
        float norm_wl_max = sigmoid_normalize(current_data->water_level.max, params->norm_water_level_L, params->norm_water_level_U);

        // 2. 计算漫顶风险 (Overflow)
        results_array[i].overflow.min = params->overflow_base + params->w_overflow_wave_height * norm_wh_min + params->w_overflow_water_level * norm_wl_min;
        results_array[i].overflow.max = params->overflow_base + params->w_overflow_wave_height * norm_wh_max + params->w_overflow_water_level * norm_wl_max;

        // 3. 计算失稳风险 (Instability)
        results_array[i].instability.min = params->instability_base + params->w_instability_wave_height * norm_wh_min + params->w_instability_water_level * norm_wl_min;
        results_array[i].instability.max = params->instability_base + params->w_instability_wave_height * norm_wh_max + params->w_instability_water_level * norm_wl_max;

        // 4. 计算溃口风险 (Breach)
        results_array[i].breach.min = params->w_breach_overflow * results_array[i].overflow.min + params->w_breach_instability * results_array[i].instability.min;
        results_array[i].breach.max = params->w_breach_overflow * results_array[i].overflow.max + params->w_breach_instability * results_array[i].instability.max;

        // 5. 计算综合风险 (Total)
        results_array[i].total.min = params->w_total_overflow * results_array[i].overflow.min + params->w_total_breach * results_array[i].breach.min;
        results_array[i].total.max = params->w_total_overflow * results_array[i].overflow.max + params->w_total_breach * results_array[i].breach.max;
                                     
        // 6. (推荐) 对所有最终结果进行钳位，确保在[0,1]范围内
        results_array[i].total.min = clamp(results_array[i].total.min, 0.0f, 1.0f);
        results_array[i].total.max = clamp(results_array[i].total.max, 0.0f, 1.0f);
    }
}

```
</file>
<file path="Model\Algorithm.h">
```h
#ifndef __ALGORITHM_H
#define __ALGORITHM_H

#include "InputParser.h"
#include "Model.h"

/**
 * @brief 存储单个时间点上所有计算出的风险指数
 */
typedef struct {
    MinMaxFloat overflow;
    MinMaxFloat instability;
    MinMaxFloat breach;
    MinMaxFloat total;
} RiskResult;

/**
  * @brief  根据输入的预报数据和模型参数，计算所有时间点的风险指数
  * @param  input 指向已解析的输入数据 (ForecastInput)
  * @param  params 指向当前有效的模型参数 (RiskModelParameters)
  * @param  results_array 指向一个RiskResult数组，用于存储计算结果。其大小应至少为 input->time_series_count。
  * @retval 无
  */
void Algorithm_CalculateAllRisks(const ForecastInput* input, const RiskModelParameters* params, RiskResult* results_array);

#endif // __ALGORITHM_H

```
</file>
<file path="Model\Indicator.c">
```c
#include "Indicator.h"
#include <stdio.h> // for printf

/**
  * @brief  [已修改] 通过串口打印详细的风险报告，包含四种风险指数
  * @note   采用逐行打印的方式，避免单次printf消耗过多堆栈空间
  */
void Indicator_ShowRiskResults(const ForecastInput* input, const RiskResult* results)
{
    printf("\r\n=============== Risk Calculation Report ===============\r\n");
    printf("Station ID: %s\r\n", input->station_id);
    printf("Found %d time point(s) to process.\r\n", input->time_series_count);
    printf("-------------------------------------------------------\r\n");

    for (int i = 0; i < input->time_series_count; i++)
    {
        printf("\r\n[Time Point %d @ %s]\r\n", i, input->time_series[i].timestamp);
        
        // 打印输入数据
        printf("  --- Input Data ---\r\n");
        printf("    - Wave Height (min/max): %.2f / %.2f m\r\n", 
            input->time_series[i].wave_height.min, 
            input->time_series[i].wave_height.max);
        printf("    - Water Level (min/max): %.2f / %.2f m\r\n", 
            input->time_series[i].water_level.min, 
            input->time_series[i].water_level.max);
            
        // [修改] 打印详细的、分项的计算结果
        printf("  --- Calculated Risk Indices ---\r\n");
        printf("    - Overflow Risk   (漫堤): %.3f / %.3f\r\n", 
            results[i].overflow.min, 
            results[i].overflow.max);
        printf("    - Instability Risk(失稳): %.3f / %.3f\r\n", 
            results[i].instability.min, 
            results[i].instability.max);
        printf("    - Breach Risk     (溃堤): %.3f / %.3f\r\n", 
            results[i].breach.min, 
            results[i].breach.max);
        printf("    - Total Risk      (综合): %.3f / %.3f\r\n", 
            results[i].total.min, 
            results[i].total.max);
    }
    printf("\r\n===================== End of Report =====================\r\n");
}

```
</file>
<file path="Model\Indicator.h">
```h
#ifndef __INDICATOR_H
#define __INDICATOR_H

#include "InputParser.h"
#include "Algorithm.h"

/**
  * @brief  通过串口打印输入的预报数据和计算出的风险结果
  * @param  input 指向已解析的输入数据
  * @param  results 指向包含风险计算结果的数组
  * @retval 无
  */
void Indicator_ShowRiskResults(const ForecastInput* input, const RiskResult* results);

#endif // __INDICATOR_H

```
</file>
<file path="Model\Model.c">
```c
// Model/Model.c

#include "Model.h"
#include "Flash.h"
#include "Serial.h"
#include "Delay.h" // 引入Delay.h

#include <stdio.h>
#include <stdlib.h> // 用于 atof 函数 (将字符串转换为浮点数)

// 定义全局模型参数变量
RiskModelParameters g_ModelParams;

// 定义一套“出厂设置”的默认参数
const RiskModelParameters DEFAULT_PARAMS = {
    .written_flag = 42,
    .padding = {0, 0, 0},
    
    // 初始化新增的设备信息
    .station_id = 1.0f,
    .location = 1.0f,
    
    // 原始模型参数
    .overflow_base = 0.15f,
    .instability_base = 0.12f,
    .w_overflow_wave_height = 0.35f,
    .w_overflow_water_level = 0.45f,
    .w_instability_wave_height = 0.30f,
    .w_instability_water_level = 0.40f,
    .w_breach_overflow = 0.60f,
    .w_breach_instability = 0.40f,
    .w_total_overflow = 0.55f,
    .w_total_breach = 0.45f,
    .norm_wave_height_L = 4.4f,
    .norm_wave_height_U = 5.5f,
    .norm_water_level_L = 5.8f,
    .norm_water_level_U = 6.7f,
    .threshold_low = 0.3f,
    .threshold_medium = 0.6f,
    .threshold_high = 0.8f
};

// Model_Init 函数保持不变，它现在可以正常工作了
void Model_Init(void)
{
    // 1. 从Flash的起始地址读取标志位
    uint8_t flag = Flash_ReadByte(FLASH_STORE_ADDR);
    printf("Read Flag from Flash: %d\r\n", flag);

    // 2. 判断标志位是否为42
    if (flag != 42)
    {
        // Flash为空或数据损坏，加载并写入默认参数
        printf("Flag invalid. Loading default parameters and writing to Flash...\r\n");
        
        // 将默认参数复制到全局RAM变量中
        g_ModelParams = DEFAULT_PARAMS;
        
        // 将RAM中的参数写入Flash
        Flash_WriteModelParams(&g_ModelParams);
        
        printf("Default parameters written. System will auto-reset in 3 seconds...\r\n");
        
        // 延时，确保串口消息发送完毕
        Delay_ms(3000); 
        
        // 执行软件复位
        NVIC_SystemReset();
    }
    else
    {
        // Flash中有有效数据，直接读取到RAM
        printf("Flag is valid. Loading parameters from Flash...\r\n");
        Flash_ReadModelParams(&g_ModelParams);
        printf("Parameters loaded successfully.\r\n");
    }
}


/**
  * @brief  解析输入的"param"类型JSON字符串，并更新模型参数结构体
  * @param  json_string 指向包含参数JSON数据的字符串
  * @param  params_to_update 指向一个将被更新的 RiskModelParameters 结构体实例
  * @retval int 返回成功更新的参数数量，如果JSON解析失败则返回 0。
  */
int Parse_ParamInput(const char *json_string, RiskModelParameters *params_to_update)
{
    int update_count = 0;
    cJSON *root = cJSON_Parse(json_string);
    cJSON *item = NULL;

    // 如果JSON本身无法解析，则直接返回失败
    if (root == NULL) {
        printf("Error: Failed to parse param JSON string.\r\n");
        return 0;
    }

    // --- 1. 设备信息 ---
    item = cJSON_GetObjectItem(root, "station_id");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->station_id = (float)atof(item->valuestring);
        update_count++;
    }

    item = cJSON_GetObjectItem(root, "location");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->location = (float)atof(item->valuestring);
        update_count++;
    }

    // --- 2. 基础风险值 ---
    item = cJSON_GetObjectItem(root, "overflow_base");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->overflow_base = (float)atof(item->valuestring);
        update_count++;
    }

    item = cJSON_GetObjectItem(root, "instability_base");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->instability_base = (float)atof(item->valuestring);
        update_count++;
    }

    // --- 3. 漫顶风险权重 ---
    item = cJSON_GetObjectItem(root, "w_overflow_wave_height");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->w_overflow_wave_height = (float)atof(item->valuestring);
        update_count++;
    }

    item = cJSON_GetObjectItem(root, "w_overflow_water_level");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->w_overflow_water_level = (float)atof(item->valuestring);
        update_count++;
    }

    // --- 4. 失稳风险权重 ---
    item = cJSON_GetObjectItem(root, "w_instability_wave_height");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->w_instability_wave_height = (float)atof(item->valuestring);
        update_count++;
    }

    item = cJSON_GetObjectItem(root, "w_instability_water_level");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->w_instability_water_level = (float)atof(item->valuestring);
        update_count++;
    }

    // --- 5. 溃口风险权重 ---
    item = cJSON_GetObjectItem(root, "w_breach_overflow");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->w_breach_overflow = (float)atof(item->valuestring);
        update_count++;
    }

    item = cJSON_GetObjectItem(root, "w_breach_instability");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->w_breach_instability = (float)atof(item->valuestring);
        update_count++;
    }

    // --- 6. 综合风险权重 ---
    item = cJSON_GetObjectItem(root, "w_total_overflow");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->w_total_overflow = (float)atof(item->valuestring);
        update_count++;
    }

    item = cJSON_GetObjectItem(root, "w_total_breach");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->w_total_breach = (float)atof(item->valuestring);
        update_count++;
    }

    // --- 7. 归一化参数 ---
    item = cJSON_GetObjectItem(root, "norm_wave_height_L");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->norm_wave_height_L = (float)atof(item->valuestring);
        update_count++;
    }

    item = cJSON_GetObjectItem(root, "norm_wave_height_U");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->norm_wave_height_U = (float)atof(item->valuestring);
        update_count++;
    }

    item = cJSON_GetObjectItem(root, "norm_water_level_L");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->norm_water_level_L = (float)atof(item->valuestring);
        update_count++;
    }

    item = cJSON_GetObjectItem(root, "norm_water_level_U");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->norm_water_level_U = (float)atof(item->valuestring);
        update_count++;
    }

    // --- 8. 风险等级阈值 ---
    item = cJSON_GetObjectItem(root, "threshold_low");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->threshold_low = (float)atof(item->valuestring);
        update_count++;
    }

    item = cJSON_GetObjectItem(root, "threshold_medium");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->threshold_medium = (float)atof(item->valuestring);
        update_count++;
    }

    item = cJSON_GetObjectItem(root, "threshold_high");
    if (item != NULL && cJSON_IsString(item)) {
        params_to_update->threshold_high = (float)atof(item->valuestring);
        update_count++;
    }

    // 释放cJSON对象占用的内存
    cJSON_Delete(root);

    return update_count;
}


```
</file>
<file path="Model\Model.h">
```h
#ifndef __MODEL_H
#define __MODEL_H

#include "stm32f10x.h"
#include "Model.h"   // 需要了解 RiskModelParameters 结构
#include "cJSON.h"   // 需要使用 cJSON 库

typedef struct {
    // --- 将1字节的标志位放在最前面 ---
    uint8_t written_flag;
    
    // --- 为了保证后续float成员4字节对齐，我们手动填充3个字节 ---
    uint8_t padding[3]; 
    
    // --- 新增的设备信息 ---
    float station_id;
    float location; // 暂时用float，后续可改为更复杂结构
    
    // --- 原始模型参数 ---
    float overflow_base;
    float instability_base;
    float w_overflow_wave_height;
    float w_overflow_water_level;
    float w_instability_wave_height;
    float w_instability_water_level;
    float w_breach_overflow;
    float w_breach_instability;
    float w_total_overflow;
    float w_total_breach;
    float norm_wave_height_L;
    float norm_wave_height_U;
    float norm_water_level_L;
    float norm_water_level_U;
    float threshold_low;
    float threshold_medium;
    float threshold_high;

} RiskModelParameters;


// 声明一个全局变量，用于在RAM中存储当前有效的模型参数
extern RiskModelParameters g_ModelParams;

// 函数原型
void Model_Init(void);

/**
  * @brief  解析输入的"param"类型JSON字符串，并更新模型参数结构体
  * @param  json_string 指向包含参数JSON数据的字符串
  * @param  params_to_update 指向一个将被更新的 RiskModelParameters 结构体实例
  * @retval int 返回成功更新的参数数量，如果解析失败则返回 0。
  */
int Parse_ParamInput(const char *json_string, RiskModelParameters *params_to_update);

#endif

```
</file>
<file path="System\Delay.c">
```c
#include "stm32f10x.h"

/**
  * @brief  微秒级延时
  * @param  xus 延时时长，范围：0~233015
  * @retval 无
  */
void Delay_us(uint32_t xus)
{
	SysTick->LOAD = 72 * xus;				//设置定时器重装值
	SysTick->VAL = 0x00;					//清空当前计数值
	SysTick->CTRL = 0x00000005;				//设置时钟源为HCLK，启动定时器
	while(!(SysTick->CTRL & 0x00010000));	//等待计数到0
	SysTick->CTRL = 0x00000004;				//关闭定时器
}

/**
  * @brief  毫秒级延时
  * @param  xms 延时时长，范围：0~4294967295
  * @retval 无
  */
void Delay_ms(uint32_t xms)
{
	while(xms--)
	{
		Delay_us(1000);
	}
}
 
/**
  * @brief  秒级延时
  * @param  xs 延时时长，范围：0~4294967295
  * @retval 无
  */
void Delay_s(uint32_t xs)
{
	while(xs--)
	{
		Delay_ms(1000);
	}
} 

```
</file>
<file path="System\Delay.h">
```h
#ifndef __DELAY_H
#define __DELAY_H

void Delay_us(uint32_t us);
void Delay_ms(uint32_t ms);
void Delay_s(uint32_t s);

#endif

```
</file>
<file path="User\main.c">
```c
#include "stm32f10x.h"
#include "Delay.h"
#include "LED.h"
#include "Serial.h"
#include "Timer.h"
#include "Model.h"
#include "Flash.h"
#include "InputParser.h"
#include "Algorithm.h"
#include "Indicator.h"
#include <string.h>

// --- 批次接收状态机定义 ---
typedef enum {
    STATE_IDLE,
    STATE_RECEIVING
} BatchState;

// --- 全局状态变量 ---
volatile BatchState g_batch_state = STATE_IDLE;
volatile uint8_t g_TimeoutFlag = 0;

char      g_current_batch_id[BATCH_ID_MAX_LEN];
uint8_t   g_expected_frames = 0;
uint32_t  g_received_frames_mask = 0;
uint8_t   g_received_frames_count = 0;

ForecastInput g_BatchBuffer;
static char processing_buffer[SERIAL_RX_BUFFER_SIZE];


// --- 前向声明 ---
static void Process_DataPacket(const char *json_str);
static void Process_ParamPacket(const char *json_str);
void Process_ReceivedPacket(const char *packet_buffer);
static void Handle_BatchTimeout(void);
static void Reset_BatchState(void);
static void Run_FlashCorruptionTest_ForNextBoot(void); // [新增] 测试函数的声明


/**
  * @brief  [新增] 封装Flash自检逻辑的测试函数
  * @note   此函数会故意污染Flash中的标志位，以测试下一次上电时
  *         系统是否能正确执行“恢复出厂设置”的流程。
  */
static void Run_FlashCorruptionTest_ForNextBoot(void)
{
    printf("\n[Test Logic] Invalidating Flash flag to 41 for next boot test.\n");
    g_ModelParams.written_flag = 41; // 在RAM中将标志位设置为无效值
    Flash_WriteModelParams(&g_ModelParams); // 将包含无效标志的结构体写回Flash
}


/**
  * @brief  主函数
  */
int main(void)
{
    // 1. 初始化所有硬件和模块
    LED_Init();
    Serial_Init();
    Model_Init();
    Timeout_Timer_Init();
    
    printf("\r\n--- System Boot ---\r\n");
    
    for (int i = 0; i < 4; i++) {
        LED1_Turn();
        Delay_ms(200);
    }
    LED1_OFF();
    
    // [修改] 调用封装好的测试函数。后续可直接注释掉此行来禁用该功能。
    Run_FlashCorruptionTest_ForNextBoot();
    
    printf("System Ready. Waiting for data or param packet...\r\n");

    // 2. 进入主循环
    while (1)
    {
        if (Serial_RxFlag == 1)
        {
            LED1_ON();
            
            USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);
            strcpy(processing_buffer, Serial_RxPacket);
            Serial_RxFlag = 0;
            USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);

            Process_ReceivedPacket(processing_buffer);
            
            LED1_OFF();
        }
        
        if (g_TimeoutFlag == 1)
        {
            Handle_BatchTimeout();
        }
    }
}

// ... Process_ReceivedPacket, Process_DataPacket, Process_ParamPacket, Handle_BatchTimeout, Reset_BatchState 等函数保持完全不变 ...

/**
  * @brief  协议分发器 (此函数无变化)
  */
void Process_ReceivedPacket(const char *packet_buffer)
{
    if (strncmp(packet_buffer, "param{", 6) == 0)
    {
        Process_ParamPacket(packet_buffer + 5);
    }
    else if (strncmp(packet_buffer, "data{", 5) == 0)
    {
        Process_DataPacket(packet_buffer + 4);
    }
    else
    {
        printf("\r\n--- Unknown Packet Type ---\r\n");
    }
}

/**
  * @brief  处理 "data" 类型的分包JSON (此函数无变化)
  */
static void Process_DataPacket(const char *json_str)
{
    BatchFrame frame;
    
    if (!Parse_BatchFrame(json_str, &frame))
    {
        printf("Packet parsing failed. Ignoring.\r\n");
        return;
    }
    
    printf("Received Frame: BatchID=%s, Index=%d, Total=%d\r\n", frame.batch_id, frame.frame_index, frame.total_frames);

    if (g_batch_state == STATE_IDLE)
    {
        if (frame.frame_index == 0)
        {
            printf("New batch started. State -> RECEIVING.\r\n");
            g_batch_state = STATE_RECEIVING;
            
            strncpy(g_current_batch_id, frame.batch_id, BATCH_ID_MAX_LEN - 1);
            g_expected_frames = frame.total_frames;
            g_received_frames_mask = 0;
            g_received_frames_count = 0;
            
            if (g_expected_frames > MAX_FRAMES_PER_BATCH) {
                printf("Error: Batch total_frames (%d) exceeds buffer size (%d).\r\n", g_expected_frames, MAX_FRAMES_PER_BATCH);
                Reset_BatchState();
                return;
            }
            
            memset(&g_BatchBuffer, 0, sizeof(g_BatchBuffer));
            strncpy(g_BatchBuffer.station_id, frame.station_id, STATION_ID_MAX_LEN - 1);
            
            Timeout_Timer_Start();
        }
        else
        {
            printf("Warning: Received non-start frame in IDLE state. Ignoring.\r\n");
            return;
        }
    }
    else
    {
        if (strcmp(g_current_batch_id, frame.batch_id) != 0)
        {
            printf("Warning: Received frame from a different batch. Ignoring.\r\n");
            return;
        }
        Timeout_Timer_Reset();
    }
    
    if (frame.frame_index >= g_expected_frames)
    {
        printf("Error: Frame index out of bounds. Ignoring.\r\n");
        return;
    }
    
    if ((g_received_frames_mask & (1 << frame.frame_index)) == 0)
    {
        g_BatchBuffer.time_series[frame.frame_index] = frame.payload;
        
        g_received_frames_mask |= (1 << frame.frame_index);
        g_received_frames_count++;
        
        printf("Frame %d stored. Progress: %d/%d\r\n", frame.frame_index, g_received_frames_count, g_expected_frames);
    }
    else
    {
        printf("Warning: Duplicate frame %d received. Ignoring.\r\n", frame.frame_index);
    }
    
    if (g_received_frames_count == g_expected_frames)
    {
        printf("\r\n--- Batch %s Complete! ---\r\n", g_current_batch_id);
        Timeout_Timer_Stop();
        
        g_BatchBuffer.time_series_count = g_expected_frames;
        RiskResult results[MAX_FRAMES_PER_BATCH];

        Algorithm_CalculateAllRisks(&g_BatchBuffer, &g_ModelParams, results);
        printf("Risk calculation complete.\r\n");

        Indicator_ShowRiskResults(&g_BatchBuffer, results);
        
        Reset_BatchState();
    }
}

/**
  * @brief  处理 "param" 包
  * @note   [优化] 更新成功后，打印当前所有模型参数的完整快照
  */
static void Process_ParamPacket(const char *json_str)
{
    printf("\r\n--- Param Packet Detected ---\r\n");
    
    // 1. 解析并更新参数
    int updated_count = Parse_ParamInput(json_str, &g_ModelParams);
    
    // 2. 如果有参数被更新
    if (updated_count > 0)
    {
        printf("Successfully updated %d parameter(s).\r\n", updated_count);
        
        // 3. 写入Flash
        printf("Writing updated parameters to Flash...\r\n");
        Flash_WriteModelParams(&g_ModelParams);
        printf("Write complete. Changes will be effective after reset.\r\n");
        
        // 4. [新增] 打印当前所有模型参数的完整快照
        printf("\r\n=== Current Model Parameters Snapshot ===\r\n");
        printf("  [Device Info]\r\n");
        printf("    station_id:                %.2f\r\n", g_ModelParams.station_id);
        printf("    location:                  %.2f\r\n", g_ModelParams.location);
        
        printf("  [Base Risks]\r\n");
        printf("    overflow_base:             %.3f\r\n", g_ModelParams.overflow_base);
        printf("    instability_base:          %.3f\r\n", g_ModelParams.instability_base);
        
        printf("  [Overflow Weights]\r\n");
        printf("    w_overflow_wave_height:    %.3f\r\n", g_ModelParams.w_overflow_wave_height);
        printf("    w_overflow_water_level:    %.3f\r\n", g_ModelParams.w_overflow_water_level);
        
        printf("  [Instability Weights]\r\n");
        printf("    w_instability_wave_height: %.3f\r\n", g_ModelParams.w_instability_wave_height);
        printf("    w_instability_water_level: %.3f\r\n", g_ModelParams.w_instability_water_level);
        
        printf("  [Breach Weights]\r\n");
        printf("    w_breach_overflow:         %.3f\r\n", g_ModelParams.w_breach_overflow);
        printf("    w_breach_instability:      %.3f\r\n", g_ModelParams.w_breach_instability);
        
        printf("  [Total Weights]\r\n");
        printf("    w_total_overflow:          %.3f\r\n", g_ModelParams.w_total_overflow);
        printf("    w_total_breach:            %.3f\r\n", g_ModelParams.w_total_breach);
        
        printf("  [Normalization Params]\r\n");
        printf("    norm_wave_height_L/U:      %.2f / %.2f\r\n", g_ModelParams.norm_wave_height_L, g_ModelParams.norm_wave_height_U);
        printf("    norm_water_level_L/U:      %.2f / %.2f\r\n", g_ModelParams.norm_water_level_L, g_ModelParams.norm_water_level_U);
        
        printf("  [Thresholds]\r\n");
        printf("    Low/Medium/High:           %.2f / %.2f / %.2f\r\n", g_ModelParams.threshold_low, g_ModelParams.threshold_medium, g_ModelParams.threshold_high);
        printf("=========================================\r\n");
    }
    else
    {
        printf("--- Param Packet Parsing Failed or No valid parameters found ---\r\n");
    }
}

/**
  * @brief  处理数据包接收超时事件 (此函数无变化)
  */
static void Handle_BatchTimeout(void)
{
    g_TimeoutFlag = 0;
    if (g_batch_state == STATE_RECEIVING)
    {
        printf("\r\n--- ERROR: Batch Reception Timeout! ---\r\n");
        printf("Batch ID: %s\r\n", g_current_batch_id);
        printf("Expected %d frames, but only received %d.\r\n", g_expected_frames, g_received_frames_count);
        
        Reset_BatchState();
    }
}

/**
  * @brief  重置批次状态机到初始状态 (此函数无变化)
  */
static void Reset_BatchState(void)
{
    g_batch_state = STATE_IDLE;
    g_current_batch_id[0] = '\0';
    g_expected_frames = 0;
    g_received_frames_mask = 0;
    g_received_frames_count = 0;
    printf("\r\nState machine reset to IDLE. Waiting for new batch...\r\n");
}

```
</file>
</project_files>