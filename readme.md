# LoRaPlat: 一个高可靠、可扩展的嵌入式 LoRa 通信平台

## 1. 项目简介

本项目旨在从零开始，在 STM32F103C8T6 裸机环境下，构建一个具备工业级健壮性雏形的 LoRa 无线通信平台。它不仅实现了可靠的数据传输，更通过一个清晰的、逐步演进的分层架构和一系列健常用性设计，系统性地解决了嵌入式无线通信中的常见工程挑战。

本文档将全面回顾项目从初期探索到当前 V2.0 版本的技术演进历程，重点阐述架构决策、关键问题解决方案及经验沉淀。

## 2. 核心特性

*   **分层软件架构:** 采用清晰的四层软件架构（应用层/服务层/协议层/驱动层），实现了业务逻辑与底层硬件的有效解耦，为跨平台移植和功能扩展奠定了基础。
*   **高可靠协议栈:** 自主设计并实现了一套轻量级私有协议。该协议支持 **ACK 确认、超时重传、CRC16 校验**，确保数据在不可靠的无线信道上能够可靠送达。
*   **高性能驱动:** 基于 **DMA 循环模式 + 读写双指针** 的方式重构了 UART 驱动，从根本上解决了在 115200 高波特率下因 CPU 处理延迟导致的硬件数据丢包问题。
*   **非阻塞设计:** 整个协议栈由一个基于 `GetTick()` 的**非阻塞状态机**驱动，避免了在主循环中使用任何阻塞式延时，可在裸机环境下高效运行，并具备向 RTOS 迁移的潜力。
*   **动态与持久化配置:** 支持通过无线网络，使用 JSON 格式指令对节点的网络地址、信道、功率等核心参数进行**远程配置**，并可将配置**持久化**到 STM32 内部 Flash。
*   **身份自管理:** 实现了节点的 **UUID (Universally Unique Identifier)** 唯一身份管理机制。设备在首次上电时，可通过采集 ADC 底噪作为熵源，自动生成并固化一个 32 位的唯一标识符，解决了批量设备身份冲突的问题。

## 3. 技术栈

*   **主控 MCU:** STM32F103C8T6
*   **LoRa 模块:** ATK-LORA-01 (内部核心: Semtech SX1278)
*   **开发环境:** Keil 5
*   **固件库:** STM32F10x Standard Peripherals Library (StdPeriph_Lib)
*   **核心技术:** C 语言, 裸机开发, DMA, RTC, 状态机设计, 私有协议栈开发

## 4. 软件架构演进

本项目的架构并非一次成型，而是经历了从一个简单的三层模型到一个职责更清晰的四层模型的演进过程。

### 4.1 早期三层模型 (V1.0)

在项目初期，为了快速验证功能，我们采用了一个经典的三层架构：

*   **Layer 3: 硬件驱动层 (BSP):** 负责初始化 UART、GPIO 等硬件，并提供基本的字节收发接口。
*   **Layer 2: 模块中间件 (Module):** 负责封装对 ATK-LORA-01 模块的 AT 指令操作、数据包的拼装与解析。
*   **Layer 1: 测试应用层 (Test):** 负责实现具体的业务逻辑，如回响测试。

这个架构的优点是简单直观，但很快暴露了其耦合性问题：`Module` 层既要处理 AT 指令，又要处理协议逻辑，职责不清；同时，它强依赖于 ATK-LORA-01 的特定指令集。

### 4.2 当前四层模型 (V2.0)

为了解决上述问题，我们将原有的 `Module` 层一分为二，并明确了各层职责，形成了当前的四层架构：

*   **Layer 4: 应用层 (APP):**
    *   **职责:** 纯粹的业务逻辑实现。负责解析最终的业务数据（如 JSON 指令），并执行相应的动作（如控制 LED、更新参数）。它不关心数据是如何传输的。
    *   **交互:** 通过回调函数接收来自服务层的数据，通过 API 请求服务层发送数据。

*   **Layer 3: 服务层 (Service):**
    *   **职责:** 作为应用层与协议层之间的“适配器”或“胶水层”。它将底层复杂的协议事件（如收到 ACK、发送成功/失败）转换为简洁的应用层事件，并为应用层提供如 `SendPacket()` 这样简单明了的接口。
    *   **交互:** 注册协议层的回调，调用协议层的 API。

*   **Layer 2: 协议/驱动层 (Manager/Driver):**
    *   **职责:** 项目的“大脑”，是协议栈和设备驱动的核心。
        *   **Manager:** 负责协议状态机（发送、等待 ACK、重传）、协议帧的封包/解包、CRC 校验、地址过滤等纯逻辑。它不直接与任何硬件交互。
        *   **Driver:** 负责将 `Manager` 的通用指令（如“设置地址”、“发送数据”）翻译成特定硬件（ATK-LORA-01）的 AT 指令。
    *   **交互:** `Manager` 调用 `Driver` 的接口来控制模块，`Driver` 调用 `Port` 层的接口来收发数据。

*   **Layer 1: 硬件抽象/BSP 层 (Port/BSP):**
    *   **职责:** 平台相关的最底层代码。负责直接操作 MCU 的硬件寄存器（GPIO, UART, DMA, Flash），并向上层提供原子化的硬件操作接口（如 `Port_WriteData`, `Port_ReadData`）。
    *   **交互:** 这是唯一与具体 MCU 型号（STM32F103）相关的层。未来若需移植到其他 MCU，理论上只需重写这一层。

这一架构通过依赖倒置，实现了 `Manager` 层对具体 LoRa 模块的解耦，是项目能够支持未来扩展的关键。

## 5. 关键技术挑战与解决方案

### 5.1 挑战一：高波特率下的串口数据丢失

*   **问题现象:** 在 115200 波特率下，通过 UART 接收 LoRa 模块返回的数据时，出现随机性的字节丢失，导致 AT 指令响应或无线数据包解析失败。
*   **原因分析:** 最初采用的“IDLE 中断触发 -> 关闭 DMA -> CPU 处理数据 -> 重启 DMA”方案存在“失聪窗口”。在 115200bps 下，传输一个字节仅需约 86 微秒。当 CPU 正在处理数据时，新的字节到达，由于此时 DMA 已被关闭，导致硬件层面的接收溢出和数据丢失。
*   **解决方案:**
    1.  **重构 UART 驱动:** 彻底废弃中断开关 DMA 的模式，改为配置 DMA 为 **循环模式 (Circular Mode)**。在此模式下，DMA 控制器永不停止，在指定的缓冲区内自动循环写入接收到的数据。
    2.  **引入读写双指针:**
        *   硬件写指针：通过 `LORA_DRIVER_RX_BUF_SIZE - DMA_GetCurrDataCounter(DMA_Channel)` 实时计算 DMA 当前在循环缓冲区中的写入位置。
        *   软件读指针：由上层应用维护，记录已经读取到的位置。
    3.  **轮询消费:** 上层应用在主循环中通过比较读写指针的差异，来判断是否有新数据到达，并安全地读取，实现了硬件接收与软件处理的完全异步。
    *   **关键代码片段 (`bsp_lora_uart.c`):**
        ```c
        uint16_t BSP_LoRa_UART_Read(uint8_t *output_buf, uint16_t max_len)
        {
            uint16_t bytes_read = 0;
            // 计算 DMA 当前写到了哪里
            uint16_t dma_write_index = LORA_DRIVER_RX_BUF_SIZE - DMA_GetCurrDataCounter(DMA1_Channel3);
            
            // 循环读取直到追上 DMA 的写指针
            while (s_RxReadIndex != dma_write_index && bytes_read < max_len)
            {
                output_buf[bytes_read++] = s_RxBuffer[s_RxReadIndex];
                s_RxReadIndex = (s_RxReadIndex + 1) % LORA_DRIVER_RX_BUF_SIZE;
            }
            return bytes_read;
        }
        ```

### 5.2 挑战二：半双工通信中的 ACK 丢失与不必要重传

*   **问题现象:** 在双向回响测试中，从机（Slave）明确回复了 ACK 包，但主机（Host）大概率会判定为 ACK 超时，并触发不必要的重传。
*   **原因分析:**
    1.  **时序冲突:** LoRa 模块作为半双工设备，从发送 (TX) 模式切换到接收 (RX) 模式需要一定的内部处理时间。如果从机回复 ACK 过快，主机的射频前端可能还未准备好接收，导致 ACK 包丢失。
    2.  **接收缓冲区污染:** 主机在发送完数据包后，没有及时清空本地的 UART 接收缓冲区。这导致主机可能会将自己刚刚通过串口发给 LoRa 模块的数据（的回显）误当作是对方发来的 ACK，造成协议解析错位。
*   **解决方案:**
    1.  **引入 ACK 回复延时:** 在协议栈 (`Manager`) 的 ACK 发送逻辑中，增加了一个可配置的延时 `LORA_ACK_DELAY_MS`。从机在收到需要 ACK 的数据包后，会先等待几十毫秒再发出 ACK 包，为对方的收发切换预留出宝贵的“转身时间”。
    2.  **发送后清空缓冲区:** 在 `Manager` 层的状态机中，明确规定在发送数据包的操作（`LoRa_Core_SendRaw`）完成后，必须立即调用 `Port_ClearRxBuffer()`，清空所有可能存在的历史数据和发送回显，确保以一个干净的状态进入 `MGR_STATE_WAIT_ACK`。

### 5.3 挑战三：物理层与协议层的地址冲突

*   **问题现象:** 在透传模式 (`TMODE=0`) 下，当两个 LoRa 模块被配置了不同的硬件地址 (`AT+ADDR`) 时，它们之间无法通信，即使上层协议栈使用的是广播地址。
*   **原因分析:** 查阅 ATK-LORA-01 模块手册后发现，其固件在透传模式下，要求通信双方的硬件地址和信道必须完全一致，否则模块会在物理层直接丢弃数据包，数据根本无法到达上层协议栈。这与协议层希望通过软件进行地址过滤的设计产生了冲突。
*   **解决方案:** 在 `Driver` 层实现“模式-地址联动”机制。当上层请求应用配置时，`Drv_ApplyConfig` 函数会进行判断：
    *   如果配置为 **透传模式**，则强制向模块写入统一的硬件地址（如 `0x0000`），将地址过滤的权力完全上交给软件协议栈。
    *   如果配置为 **定向模式**，则写入用户指定的硬件地址，利用模块的硬件过滤能力。
    *   这一决策，实现了软件定义网络（SDN）的初步思想，保证了上层协议的灵活性不受底层硬件固件的限制。

## 6. 架构局限与未来演进方向 (Critical Review & Roadmap)

本项目虽然已实现了一个功能完备的 LoRa 通信平台，但以工业级的高并发与高可靠标准审视，当前 V2.1 架构仍存在以下局限，这也是未来深入学习与优化的方向：

### 6.1 从“同步回调”向“异步队列”演进
*   **当前局限 (The Blocking Issue):** 
    当前架构采用单线程轮询模型，接收处理链路为 `Manager -> Service -> User_Callback` 的同步调用。若用户在回调函数中执行耗时操作（如 Flash 擦除、复杂计算或阻塞延时），将直接阻塞协议栈的心跳维护与 ACK 回复，可能导致通信链路中断。
*   **改进方向:** 
    引入 **异步事件队列 (Event Queue)** 机制。Service 层收到数据后仅负责将数据“入队”，由用户在主循环的空闲时段“出队”处理。实现协议栈运行与业务逻辑处理的时间解耦，提升系统的实时响应能力。

### 6.2 从“前缀分流”向“端口复用”演进
*   **当前局限 (The Magic Prefix):** 
    V2.1 版本采用 `CMD:` 字符串前缀来区分“平台指令”与“用户数据”。这种方式虽然实现简单，但存在潜在的冲突风险（用户数据不能以 `CMD:` 开头），且字符串匹配效率较低，不利于带宽极其宝贵的 LoRa 通信。
*   **改进方向:** 
    借鉴 TCP/IP 协议思想，在协议头中增加 **逻辑端口号 (Logical Port)** 字段。例如定义 Port 0 为系统管理端口（处理 BIND/RST），Port 1-255 为用户业务端口。这将实现基于二进制位的高效、无歧义分流。

### 6.3 从“尽力而为”向“流控机制”演进
*   **当前局限 (No Flow Control):** 
    当前的发送接口是非阻塞的，若上层应用短时间内连续调用发送接口（Burst Transmission），当底层状态机处于 BUSY 状态时，后续数据包将被直接丢弃，需要用户自行处理重试逻辑。
*   **改进方向:** 
    实现 **发送 FIFO 队列** 与 **流控算法**。上层应用只需将数据写入队列，由底层驱动根据信道空闲情况（CAD）和发送完成中断自动调度发送，确保高并发场景下的数据零丢失。

### 6.4 低功耗与组网能力的补全
*   **低功耗:** 引入 RTC + STOP 模式，实现微安级的待机功耗。
*   **简易组网:** 实现基于 TDMA（时分多址）的信标同步机制，解决多节点并发冲突问题。

