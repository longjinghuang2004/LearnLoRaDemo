/**
  ******************************************************************************
  * @file    main.c
  * @author  LoRaPlat Team
  * @brief   LoRaPlat V3.8 综合测试例程 (遥控 LED + 安全指令)
  * @version V1.0
  * @date    2023-10-27
  ******************************************************************************
  */

#include "stm32f10x.h"
#include "Delay.h"
#include "Serial.h"
#include "LED.h"
#include "Flash.h"
#include "lora_service.h" 
#include "lora_service_command.h" 
#include "lora_manager.h"      
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "lora_port.h"

volatile uint8_t g_TimeoutFlag;
extern void Demo_OSAL_Init(void);
// ============================================================================
// [配置区域] 请根据烧录目标修改此处
// ============================================================================
// 1 = 主机 (Master): 发送控制指令
// 2 = 从机 (Slave):  执行动作 (亮灯)
#define DEVICE_ROLE     1

// 目标设备 ID (主机发给从机，从机发给主机)
#define TARGET_ID       ((DEVICE_ROLE == 1) ? 2 : 1)

// 默认安全令牌 (用于 CMD 指令鉴权)
#define DEFAULT_TOKEN   0x00000000

// ============================================================================
// 1. 业务层加密实现 (示例：简单异或)
// ============================================================================
uint16_t App_XOR_Crypt(const uint8_t *in, uint16_t len, uint8_t *out) {
    uint32_t key = LoRa_Service_GetConfig()->token;
    for(int i=0; i<len; i++) {
        out[i] = in[i] ^ (uint8_t)((key >> ((i % 4) * 8)) & 0xFF);
    }
    return len;
}

const LoRa_Cipher_t my_cipher = { .Encrypt = App_XOR_Crypt, .Decrypt = App_XOR_Crypt };

// ============================================================================
// 2. 适配层回调 (Adapter Layer)
// ============================================================================

void Adapter_SaveConfig(const LoRa_Config_t *cfg) { Flash_WriteLoRaConfig(cfg); }
void Adapter_LoadConfig(LoRa_Config_t *cfg)       { Flash_ReadLoRaConfig(cfg); }
uint32_t Adapter_GetRandomSeed(void)              { return LoRa_Port_GetEntropy32(); }
void Adapter_SystemReset(void)                    { NVIC_SystemReset(); }

// [核心] 接收数据回调
void Adapter_OnRecvData(uint16_t src_id, const uint8_t *data, uint16_t len, LoRa_RxMeta_t *meta) {
    // 1. 打印日志 (此时 data 已经是解密后的明文)
    Serial_Printf("[RX] From 0x%04X (RSSI:%d): %.*s\r\n", src_id, meta->rssi, len, data);
    
    // 2. 业务逻辑处理 (Business Logic)
    // ---------------------------------------------------------
    // 场景 A: 远程 LED 控制
    if (strncmp((char*)data, "LED_ON", 6) == 0) {
        LED2_ON(); // 点亮板载 LED2
        Serial_Printf("[APP] Action: LED2 ON\r\n");
    }
    else if (strncmp((char*)data, "LED_OFF", 7) == 0) {
        LED2_OFF(); // 熄灭板载 LED2
        Serial_Printf("[APP] Action: LED2 OFF\r\n");
    }
    
    // 场景 B: 平台管理指令 (CMD:Token:...)
    // 注意：这是可选功能，由用户决定是否启用
    else if (len > 4 && strncmp((char*)data, "CMD:", 4) == 0) {
        char cmd_buf[128];
        if (len < sizeof(cmd_buf)) {
            memcpy(cmd_buf, data, len);
            cmd_buf[len] = '\0';
            if (LoRa_Service_Command_Process(cmd_buf)) {
                Serial_Printf("[APP] Admin Command Executed.\r\n");
            } else {
                Serial_Printf("[APP] Admin Command Rejected.\r\n");
            }
        }
    }
}

// 事件回调
void Adapter_OnEvent(LoRa_Event_t event, void *arg) {
    switch(event) {
        case LORA_EVENT_INIT_SUCCESS: Serial_Printf("[EVT] LoRa Init OK. Role: %d\r\n", DEVICE_ROLE); break;
        case LORA_EVENT_TX_FINISHED:  Serial_Printf("[EVT] TX Finished (ACK OK).\r\n"); LED1_Turn(); break; // LED1 闪烁表示发送成功
        case LORA_EVENT_TX_FAILED:    Serial_Printf("[EVT] TX Failed (Timeout).\r\n"); break;
        case LORA_EVENT_BIND_SUCCESS: Serial_Printf("[EVT] Bind ID: %d\r\n", *(uint16_t*)arg); break;
        default: break;
    }
}

const LoRa_Callback_t my_adapter = {
    .SaveConfig = Adapter_SaveConfig, .LoadConfig = Adapter_LoadConfig,
    .GetRandomSeed = Adapter_GetRandomSeed, .SystemReset = Adapter_SystemReset,
    .OnRecvData = Adapter_OnRecvData, .OnEvent = Adapter_OnEvent
};

// ============================================================================
// 3. 辅助函数：首次运行初始化
// ============================================================================
void Check_First_Run(void) {
    LoRa_Config_t cfg;
    Flash_ReadLoRaConfig(&cfg);
    if (cfg.magic != LORA_CFG_MAGIC) {
        Serial_Printf("[SYS] First Run, Writing Defaults...\r\n");
        memset(&cfg, 0, sizeof(cfg));
        cfg.magic = LORA_CFG_MAGIC;
        cfg.net_id = DEVICE_ROLE; // 1 or 2
        cfg.group_id = 100;
        cfg.token = DEFAULT_TOKEN;
        cfg.hw_addr = 0;
        cfg.channel = 23;
        cfg.power = 0; // 11dBm
        cfg.air_rate = 5; // 19.2k
        cfg.tmode = 0; // Transparent
        Flash_WriteLoRaConfig(&cfg);
        NVIC_SystemReset();
    }
}

// ============================================================================
// 4. 主函数
// ============================================================================
int main(void)
{
    // 硬件初始化
    SysTick_Init();
    LED_Init();
    Serial_Init();
    Demo_OSAL_Init();
    Check_First_Run(); // 检查 Flash
    
    // 注册加密算法 (可选)
    LoRa_Manager_RegisterCipher(&my_cipher);
    
    // 启动协议栈
    // 强制覆盖 NetID 以匹配当前 Role (方便调试，实际产品可去掉)
    LoRa_Service_Init(&my_adapter, DEVICE_ROLE); 

    Serial_Printf("\r\n=== LoRaPlat V3.8 Demo (ID: %d) ===\r\n", DEVICE_ROLE);
    if (DEVICE_ROLE == 1) {
        Serial_Printf("Type 'ON'  -> Send LED_ON to Slave\r\n");
        Serial_Printf("Type 'OFF' -> Send LED_OFF to Slave\r\n");
    }
    Serial_Printf("Type 'CMD:00000000:INFO' -> Check Config\r\n");

    char input_buf[128];
    uint32_t last_heartbeat = 0;

    while (1)
    {
        // 1. 协议栈驱动
        LoRa_Service_Run();

        // 2. PC 串口指令处理 (用户输入)
        if (Serial_GetRxPacket(input_buf, sizeof(input_buf))) {
            Serial_Printf("[PC] Input: %s\r\n", input_buf);
            
            // --- 业务指令 (发送给对方) ---
            if (strcmp(input_buf, "ON") == 0) {
                if (LoRa_Service_Send((uint8_t*)"LED_ON", 6, TARGET_ID))
                    Serial_Printf(" -> Sending LED_ON...\r\n");
                else
                    Serial_Printf(" -> Send Failed (Busy)\r\n");
            }
            else if (strcmp(input_buf, "OFF") == 0) {
                if (LoRa_Service_Send((uint8_t*)"LED_OFF", 7, TARGET_ID))
                    Serial_Printf(" -> Sending LED_OFF...\r\n");
                else
                    Serial_Printf(" -> Send Failed (Busy)\r\n");
            }
            
            // --- 本地管理指令 (配置自己) ---
            // 格式: CMD:Token:Command
            else if (strncmp(input_buf, "CMD:", 4) == 0) {
                if (LoRa_Service_Command_Process(input_buf))
                    Serial_Printf(" -> Admin Cmd Executed.\r\n");
                else
                    Serial_Printf(" -> Admin Cmd Failed.\r\n");
            }
        }

        // 3. 心跳 (仅 LED1 闪烁，LED2 用于业务指示)
        if (GetTick() - last_heartbeat > 1000) {
            last_heartbeat = GetTick();
            LED1_Turn(); 
        }
    }
}
