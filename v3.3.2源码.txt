## Directory Structure for `LoRaPlat`

```
- LoRaPlat的项目暂定版本/
    - LoRa_Plat/
        - 0_OSAL/
            - lora_osal.c
            - lora_osal.h
        - 0_Utils/
            - lora_crc16.c
            - lora_crc16.h
            - lora_ring_buffer.c
            - lora_ring_buffer.h
        - 1_Port/
            - lora_port.h
            - lora_port_stm32f10x.c
        - 2_Driver/
            - lora_at_command_engine.c
            - lora_at_command_engine.h
            - lora_driver.c
            - lora_driver.h
            - lora_driver_config.c
            - lora_driver_core.c
        - 3_Manager/
            - lora_manager.c
            - lora_manager.h
            - lora_manager_buffer.c
            - lora_manager_buffer.h
            - lora_manager_fsm.c
            - lora_manager_fsm.h
            - lora_manager_protocol.c
            - lora_manager_protocol.h
        - 4_Service/
            - lora_service.c
            - lora_service.h
            - lora_service_command.c
            - lora_service_command.h
            - lora_service_config.c
            - lora_service_config.h
    - User/
        - lora_demo_osal.c
        - main.c
```


---

## File Contents

<project_files>
<file path="LoRa_Plat\0_OSAL\lora_osal.c">
```c
/**
  ******************************************************************************
  * @file    lora_osal.c
  * @author  LoRaPlat Team
  * @brief   操作系统抽象层 (OSAL) 实现 V3.2.1 (Fix Warnings)
  ******************************************************************************
  */

#include "lora_osal.h"
#include <stdio.h> 

// ============================================================
//                    1. 默认桩函数 (Safety Stubs)
// ============================================================

static uint32_t Stub_GetTick(void) { return 0; }
static void     Stub_DelayMs(uint32_t ms) { (void)ms; }
static void     Stub_EnterCritical(void) {}
static void     Stub_ExitCritical(void) {}
static void*    Stub_Malloc(uint32_t size) { (void)size; return NULL; }
static void     Stub_Free(void* ptr) { (void)ptr; }
static void     Stub_LogHex(const char *tag, const void *data, uint16_t len) { (void)tag; (void)data; (void)len; }

static LoRa_OSAL_Interface_t s_Impl = {
    .GetTick       = Stub_GetTick,
    .DelayMs       = Stub_DelayMs,
    .EnterCritical = Stub_EnterCritical,
    .ExitCritical  = Stub_ExitCritical,
    .Log           = NULL, 
    .LogHex        = Stub_LogHex,
    .Malloc        = Stub_Malloc,
    .Free          = Stub_Free
};

static bool s_IsInit = false;

// ============================================================
//                    2. 初始化
// ============================================================

bool LoRa_OSAL_Init(const LoRa_OSAL_Interface_t *impl) {
    if (impl == NULL) return false;
    
    if (!impl->GetTick || !impl->DelayMs || !impl->EnterCritical || !impl->ExitCritical) {
        return false; 
    }
    
    s_Impl.GetTick       = impl->GetTick;
    s_Impl.DelayMs       = impl->DelayMs;
    s_Impl.EnterCritical = impl->EnterCritical;
    s_Impl.ExitCritical  = impl->ExitCritical;
    
    if (impl->Log)    s_Impl.Log    = impl->Log;
    if (impl->Malloc) s_Impl.Malloc = impl->Malloc;
    if (impl->Free)   s_Impl.Free   = impl->Free;
    
    // 智能 HexDump 注册
    if (impl->LogHex) {
        s_Impl.LogHex = impl->LogHex;
    } 
    
    s_IsInit = true;
    return true;
}

// ============================================================
//                    3. 核心包装器
// ============================================================

uint32_t _osal_get_tick(void) { return s_Impl.GetTick(); }
void     _osal_delay_ms(uint32_t ms) { s_Impl.DelayMs(ms); }
void     _osal_enter_critical(void) { s_Impl.EnterCritical(); }
void     _osal_exit_critical(void) { s_Impl.ExitCritical(); }
void*    _osal_malloc(uint32_t size) { return s_Impl.Malloc(size); }
void     _osal_free(void* ptr) { s_Impl.Free(ptr); }

// ============================================================
//                    4. 日志包装器
// ============================================================

#if (defined(LORA_DEBUG_PRINT) && LORA_DEBUG_PRINT == 1)

void _osal_log_wrapper(const char *fmt, ...) {
    if (!s_IsInit || s_Impl.Log == NULL) return;
    
    va_list args;
    va_start(args, fmt);
    s_Impl.Log(fmt, args);
    va_end(args);
}

void _osal_hexdump_wrapper(const char *tag, const void *data, uint16_t len) {
    if (!s_IsInit) return;

    // 1. 优先使用用户提供的 HexDump
    if (s_Impl.LogHex != Stub_LogHex) {
        s_Impl.LogHex(tag, data, len);
        return;
    }

    // 2. 否则使用默认实现 (依赖 Log 接口)
    if (s_Impl.Log == NULL) return;

    const uint8_t *p = (const uint8_t*)data;
    char buf[64]; 
    
    _osal_log_wrapper("%s (Len=%d): ", tag, len);

    #define CHUNK_SIZE 16
    for (uint16_t i = 0; i < len; i += CHUNK_SIZE) {
        uint16_t chunk = (len - i < CHUNK_SIZE) ? (len - i) : CHUNK_SIZE;
        int pos = 0;
        for (uint16_t j = 0; j < chunk; j++) {
            pos += sprintf(buf + pos, "%02X ", p[i + j]);
        }
        _osal_log_wrapper("%s", buf);
    }
    _osal_log_wrapper("\r\n");
}

#endif

```
</file>
<file path="LoRa_Plat\0_OSAL\lora_osal.h">
```h
#ifndef __LORA_OSAL_H
#define __LORA_OSAL_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdarg.h>
#include "LoRaPlatConfig.h" 

// ============================================================
//                    1. 接口定义
// ============================================================

typedef struct {
    // --- 核心服务 (必须提供) ---
    uint32_t (*GetTick)(void);          
    void     (*DelayMs)(uint32_t ms);   
    void     (*EnterCritical)(void);    
    void     (*ExitCritical)(void);     
    
    // --- 调试服务 (可选) ---
    // 仅当 LORA_DEBUG_PRINT=1 时有效
    void     (*Log)(const char *fmt, va_list args);
    // [恢复功能] 允许用户提供自定义 HexDump，若为 NULL 则使用默认实现
    void     (*LogHex)(const char *tag, const void *data, uint16_t len);
    
    // --- 内存服务 (可选) ---
    void*    (*Malloc)(uint32_t size);
    void     (*Free)(void* ptr);
    
} LoRa_OSAL_Interface_t;

// ============================================================
//                    2. 初始化 API
// ============================================================

bool LoRa_OSAL_Init(const LoRa_OSAL_Interface_t *impl);

// ============================================================
//                    3. 业务调用宏
// ============================================================

uint32_t _osal_get_tick(void);
void     _osal_delay_ms(uint32_t ms);
void     _osal_enter_critical(void);
void     _osal_exit_critical(void);
void*    _osal_malloc(uint32_t size);
void     _osal_free(void* ptr);

#define OSAL_GetTick()          _osal_get_tick()
#define OSAL_DelayMs(ms)        _osal_delay_ms(ms)
#define OSAL_EnterCritical()    _osal_enter_critical()
#define OSAL_ExitCritical()     _osal_exit_critical()
#define OSAL_Malloc(sz)         _osal_malloc(sz)
#define OSAL_Free(ptr)          _osal_free(ptr)

// --- 日志宏 (编译期优化) ---
#if (defined(LORA_DEBUG_PRINT) && LORA_DEBUG_PRINT == 1)
    void _osal_log_wrapper(const char *fmt, ...);
    void _osal_hexdump_wrapper(const char *tag, const void *data, uint16_t len);
    
    #define LORA_LOG(...)       _osal_log_wrapper(__VA_ARGS__)
    #define LORA_HEXDUMP(t,d,l) _osal_hexdump_wrapper(t,d,l)
#else
    #define LORA_LOG(...)       do {} while (0)
    #define LORA_HEXDUMP(t,d,l) do {} while (0)
#endif

#endif // __LORA_OSAL_H

```
</file>
<file path="LoRa_Plat\0_Utils\lora_crc16.c">
```c
/**
  ******************************************************************************
  * @file    lora_crc16.c
  * @author  LoRaPlat Team
  * @brief   CRC16-CCITT (XMODEM) 实现
  ******************************************************************************
  */

#include "lora_crc16.h"

uint16_t LoRa_CRC16_Calculate(const uint8_t *data, uint16_t length) {
    uint16_t crc = 0x0000;
    
    while (length--) {
        crc ^= (uint16_t)(*data++) << 8;
        for (int i = 0; i < 8; i++) {
            if (crc & 0x8000) {
                crc = (crc << 1) ^ 0x1021;
            } else {
                crc <<= 1;
            }
        }
    }
    return crc;
}

uint8_t LoRa_CRC16_Verify(const uint8_t *data, uint16_t length, uint16_t expected_crc) {
    uint16_t calc = LoRa_CRC16_Calculate(data, length);
    return (calc == expected_crc) ? 1 : 0;
}

```
</file>
<file path="LoRa_Plat\0_Utils\lora_crc16.h">
```h
/**
  ******************************************************************************
  * @file    lora_crc16.h
  * @author  LoRaPlat Team
  * @brief   CRC16-CCITT (XMODEM) 计算工具
  *          Poly: 0x1021, Init: 0x0000
  ******************************************************************************
  */

#ifndef __LORA_CRC16_H
#define __LORA_CRC16_H

#include <stdint.h>
#include <stddef.h>

/**
 * @brief  计算 CRC16
 * @param  data: 数据指针
 * @param  length: 数据长度
 * @return CRC16 校验码
 */
uint16_t LoRa_CRC16_Calculate(const uint8_t *data, uint16_t length);

/**
 * @brief  校验 CRC16
 * @param  data: 数据指针
 * @param  length: 数据长度
 * @param  expected_crc: 期望的校验码
 * @return 1=校验通过, 0=校验失败
 */
uint8_t LoRa_CRC16_Verify(const uint8_t *data, uint16_t length, uint16_t expected_crc);

#endif // __LORA_CRC16_H

```
</file>
<file path="LoRa_Plat\0_Utils\lora_ring_buffer.c">
```c
/**
  ******************************************************************************
  * @file    lora_ring_buffer.c
  * @author  LoRaPlat Team
  * @brief   通用环形缓冲区实现
  ******************************************************************************
  */

#include "lora_ring_buffer.h"
#include <string.h> // memcpy

// ============================================================
//                    1. 核心接口实现
// ============================================================

void LoRa_RingBuffer_Init(LoRa_RingBuffer_t *rb, uint8_t *buffer, uint16_t size) {
    if (!rb || !buffer || size == 0) return;
    
    rb->pBuffer = buffer;
    rb->Size    = size;
    rb->Head    = 0;
    rb->Tail    = 0;
    rb->Count   = 0;
}

uint16_t LoRa_RingBuffer_Write(LoRa_RingBuffer_t *rb, const uint8_t *data, uint16_t length) {
    if (!rb || !data || length == 0) return 0;
    
    uint16_t free_space = rb->Size - rb->Count;
    if (length > free_space) length = free_space; // 截断写入
    
    if (length == 0) return 0;

    uint16_t chunk1 = rb->Size - rb->Head;
    
    if (length <= chunk1) {
        // 情况1: 直接写入，不需要回绕
        memcpy(&rb->pBuffer[rb->Head], data, length);
        rb->Head += length;
        if (rb->Head == rb->Size) rb->Head = 0;
    } else {
        // 情况2: 需要回绕
        memcpy(&rb->pBuffer[rb->Head], data, chunk1);
        memcpy(&rb->pBuffer[0], data + chunk1, length - chunk1);
        rb->Head = length - chunk1;
    }
    
    rb->Count += length;
    return length;
}

uint16_t LoRa_RingBuffer_Read(LoRa_RingBuffer_t *rb, uint8_t *data, uint16_t max_length) {
    if (!rb || !data || max_length == 0 || rb->Count == 0) return 0;
    
    if (max_length > rb->Count) max_length = rb->Count;
    
    uint16_t chunk1 = rb->Size - rb->Tail;
    
    if (max_length <= chunk1) {
        // 情况1: 直接读取，不需要回绕
        memcpy(data, &rb->pBuffer[rb->Tail], max_length);
        rb->Tail += max_length;
        if (rb->Tail == rb->Size) rb->Tail = 0;
    } else {
        // 情况2: 需要回绕
        memcpy(data, &rb->pBuffer[rb->Tail], chunk1);
        memcpy(data + chunk1, &rb->pBuffer[0], max_length - chunk1);
        rb->Tail = max_length - chunk1;
    }
    
    rb->Count -= max_length;
    return max_length;
}

void LoRa_RingBuffer_Clear(LoRa_RingBuffer_t *rb) {
    if (!rb) return;
    rb->Head = 0;
    rb->Tail = 0;
    rb->Count = 0;
}

// ============================================================
//                    2. 状态查询实现
// ============================================================

uint16_t LoRa_RingBuffer_GetCount(const LoRa_RingBuffer_t *rb) {
    return rb ? rb->Count : 0;
}

uint16_t LoRa_RingBuffer_GetFree(const LoRa_RingBuffer_t *rb) {
    return rb ? (rb->Size - rb->Count) : 0;
}

bool LoRa_RingBuffer_IsEmpty(const LoRa_RingBuffer_t *rb) {
    return (rb && rb->Count == 0);
}

bool LoRa_RingBuffer_IsFull(const LoRa_RingBuffer_t *rb) {
    return (rb && rb->Count == rb->Size);
}

```
</file>
<file path="LoRa_Plat\0_Utils\lora_ring_buffer.h">
```h
/**
  ******************************************************************************
  * @file    lora_ring_buffer.h
  * @author  LoRaPlat Team
  * @brief   通用环形缓冲区 (Ring Buffer) 接口定义
  *          纯逻辑实现，无硬件依赖，内存由使用者提供。
  ******************************************************************************
  */

#ifndef __LORA_RING_BUFFER_H
#define __LORA_RING_BUFFER_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

// ============================================================
//                    1. 数据结构定义
// ============================================================

typedef struct {
    uint8_t  *pBuffer;   // 指向外部提供的缓冲区数组
    uint16_t Size;       // 缓冲区总大小
    uint16_t Head;       // 写指针 (Write Index)
    uint16_t Tail;       // 读指针 (Read Index)
    uint16_t Count;      // 当前数据量
} LoRa_RingBuffer_t;

// ============================================================
//                    2. 核心接口
// ============================================================

/**
 * @brief  初始化环形缓冲区
 * @param  rb: 句柄
 * @param  buffer: 外部数组指针
 * @param  size: 数组大小
 */
void LoRa_RingBuffer_Init(LoRa_RingBuffer_t *rb, uint8_t *buffer, uint16_t size);

/**
 * @brief  写入数据 (Push)
 * @param  rb: 句柄
 * @param  data: 数据源
 * @param  length: 写入长度
 * @return 实际写入长度 (若空间不足可能小于 length)
 */
uint16_t LoRa_RingBuffer_Write(LoRa_RingBuffer_t *rb, const uint8_t *data, uint16_t length);

/**
 * @brief  读取数据 (Pop)
 * @param  rb: 句柄
 * @param  data: 目标缓冲区
 * @param  max_length: 最大读取长度
 * @return 实际读取长度
 */
uint16_t LoRa_RingBuffer_Read(LoRa_RingBuffer_t *rb, uint8_t *data, uint16_t max_length);

/**
 * @brief  清空缓冲区
 */
void LoRa_RingBuffer_Clear(LoRa_RingBuffer_t *rb);

// ============================================================
//                    3. 状态查询
// ============================================================

uint16_t LoRa_RingBuffer_GetCount(const LoRa_RingBuffer_t *rb);
uint16_t LoRa_RingBuffer_GetFree(const LoRa_RingBuffer_t *rb);
bool     LoRa_RingBuffer_IsEmpty(const LoRa_RingBuffer_t *rb);
bool     LoRa_RingBuffer_IsFull(const LoRa_RingBuffer_t *rb);

#endif // __LORA_RING_BUFFER_H

```
</file>
<file path="LoRa_Plat\1_Port\lora_port.h">
```h
/**
  ******************************************************************************
  * @file    lora_port.h
  * @author  LoRaPlat Team
  * @brief   硬件接口层 (Port Layer) 定义 V3.3.0
  *          负责屏蔽具体 MCU 的 GPIO/UART/DMA 差异。
  ******************************************************************************
  */

#ifndef __LORA_PORT_H
#define __LORA_PORT_H

#include <stdint.h>
#include <stdbool.h>

// ============================================================
//                    1. 初始化与配置
// ============================================================

/**
 * @brief  端口初始化 (GPIO, UART, DMA, NVIC)
 * @param  baudrate: 初始波特率
 */
void LoRa_Port_Init(uint32_t baudrate);

/**
 * @brief  重新配置 UART 波特率 (用于救砖或模式切换)
 */
void LoRa_Port_ReInitUart(uint32_t baudrate);

// ============================================================
//                    2. 引脚控制 (GPIO)
// ============================================================

/**
 * @brief  设置 MD0 引脚 (模式控制)
 * @param  level: true=High(配置模式), false=Low(通信模式)
 */
void LoRa_Port_SetMD0(bool level);

/**
 * @brief  设置 RST 引脚 (复位控制)
 * @param  level: true=High, false=Low(复位)
 */
void LoRa_Port_SetRST(bool level);

/**
 * @brief  获取 AUX 引脚电平 (忙闲指示)
 * @return true=High(Busy), false=Low(Idle)
 */
bool LoRa_Port_GetAUX(void);

// ============================================================
//                    3. 发送接口 (TX)
// ============================================================

/**
 * @brief  查询发送硬件是否忙碌
 * @return true=忙 (DMA正在搬运), false=闲
 */
bool LoRa_Port_IsTxBusy(void);

/**
 * @brief  发送数据 (启动 DMA)
 * @param  data: 数据指针
 * @param  len:  数据长度
 * @return 实际发送长度 (0表示硬件忙，发送失败)
 * @note   内部具有原子性保护，防止覆写缓冲区
 */
uint16_t LoRa_Port_TransmitData(const uint8_t *data, uint16_t len);

// ============================================================
//                    4. 接收接口 (RX)
// ============================================================

/**
 * @brief  从 DMA 循环缓冲区读取数据
 * @param  buf: 目标缓冲区
 * @param  max_len: 最大读取长度
 * @return 实际读取到的字节数
 */
uint16_t LoRa_Port_ReceiveData(uint8_t *buf, uint16_t max_len);

/**
 * @brief  清空接收缓冲区 (丢弃旧数据)
 * @note   通常在发送 AT 指令前调用，确保收到的是最新的响应
 */
void LoRa_Port_ClearRxBuffer(void);

// ============================================================
//                    5. 其他能力
// ============================================================

/**
 * @brief  获取物理熵源 (用于生成随机种子)
 * @return 32位随机数
 */
uint32_t LoRa_Port_GetEntropy32(void);

/**
 * @brief  同步 AUX 状态 (消除中断抖动或初始化残留)
 */
void LoRa_Port_SyncAuxState(void);

#endif // __LORA_PORT_H

```
</file>
<file path="LoRa_Plat\1_Port\lora_port_stm32f10x.c">
```c
/**
  ******************************************************************************
  * @file    lora_port_stm32f10x.c
  * @author  LoRaPlat Team
  * @brief   STM32F103 硬件接口实现 V3.3.0
  ******************************************************************************
  */

#include "lora_port.h"
#include "lora_osal.h"
#include "stm32f10x.h"
#include <string.h>

// --- DMA 缓冲区配置 ---
#define PORT_DMA_RX_BUF_SIZE 512
#define PORT_DMA_TX_BUF_SIZE 512

// 放在静态区，避免栈溢出
static uint8_t  s_DmaRxBuf[PORT_DMA_RX_BUF_SIZE];
static uint8_t  s_DmaTxBuf[PORT_DMA_TX_BUF_SIZE];
static volatile uint16_t s_RxReadIndex = 0;

// --- 状态标志 ---
static volatile bool s_TxDmaBusy = false;

// ============================================================
//                    1. 初始化与配置
// ============================================================

void LoRa_Port_Init(uint32_t baudrate)
{
    // 1. 时钟使能
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

    // 2. GPIO 配置
    GPIO_InitTypeDef GPIO_InitStructure;
    
    // PB10 -> TX
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    
    // PB11 -> RX
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; 
    GPIO_Init(GPIOB, &GPIO_InitStructure);

    // PA4 -> MD0
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    
    // PA5 -> AUX (输入)
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    // 3. USART3 配置
    LoRa_Port_ReInitUart(baudrate); 

    // 4. DMA RX (Circular) -> DMA1_Channel3
    DMA_DeInit(DMA1_Channel3);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&USART3->DR;
    DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)s_DmaRxBuf;
    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_BufferSize = PORT_DMA_RX_BUF_SIZE;
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
    DMA_InitStructure.DMA_Priority = DMA_Priority_High;
    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    DMA_Init(DMA1_Channel3, &DMA_InitStructure);

    // 5. DMA TX (Normal) -> DMA1_Channel2
    DMA_DeInit(DMA1_Channel2);
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&USART3->DR;
    DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)s_DmaTxBuf;
    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    DMA_InitStructure.DMA_BufferSize = 0;
    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    DMA_Init(DMA1_Channel2, &DMA_InitStructure);
    DMA_ITConfig(DMA1_Channel2, DMA_IT_TC, ENABLE);

    // 6. NVIC 配置
    NVIC_InitTypeDef NVIC_InitStructure;
    
    // DMA TX 中断
    NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);

    // 7. 启动
    DMA_Cmd(DMA1_Channel3, ENABLE);
    USART_DMACmd(USART3, USART_DMAReq_Rx | USART_DMAReq_Tx, ENABLE);
    USART_Cmd(USART3, ENABLE);
    
    // 初始状态同步
    LoRa_Port_SetMD0(false);
    LoRa_Port_SyncAuxState(); 
}

void LoRa_Port_ReInitUart(uint32_t baudrate) {
    USART_InitTypeDef USART_InitStructure;
    USART_InitStructure.USART_BaudRate = baudrate;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    USART_Init(USART3, &USART_InitStructure);
    
    USART_DMACmd(USART3, USART_DMAReq_Rx | USART_DMAReq_Tx, ENABLE);
    USART_Cmd(USART3, ENABLE);
}

// ============================================================
//                    2. 引脚控制
// ============================================================

void LoRa_Port_SetMD0(bool level) {
    GPIO_WriteBit(GPIOA, GPIO_Pin_4, level ? Bit_SET : Bit_RESET);
}

void LoRa_Port_SetRST(bool level) {
    // 如有 RST 引脚，在此实现
    // GPIO_WriteBit(GPIOA, GPIO_Pin_X, level ? Bit_SET : Bit_RESET);
    (void)level;
}

bool LoRa_Port_GetAUX(void) {
    return (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5) == 1);
}

void LoRa_Port_SyncAuxState(void) {
    OSAL_EnterCritical();
    // 强制复位 DMA 硬件状态
    DMA_Cmd(DMA1_Channel2, DISABLE);
    DMA1_Channel2->CNDTR = 0;
    s_TxDmaBusy = false;
    OSAL_ExitCritical();
}

// ============================================================
//                    3. 发送接口 (TX)
// ============================================================

bool LoRa_Port_IsTxBusy(void) {
    return s_TxDmaBusy;
}

uint16_t LoRa_Port_TransmitData(const uint8_t *data, uint16_t len) {
    if (len == 0 || len > PORT_DMA_TX_BUF_SIZE) return 0;

    OSAL_EnterCritical();

    // [关键修复] 双重检查：软件标志 + 硬件计数器
    // 防止上层在 IsTxBusy 返回 false 后，硬件尚未完全就绪的微小间隙
    if (s_TxDmaBusy || DMA_GetCurrDataCounter(DMA1_Channel2) != 0) {
        OSAL_ExitCritical();
        return 0; // 忙，拒绝发送
    }

    // 1. 标记忙碌
    s_TxDmaBusy = true;
    
    // 2. 填充数据 (安全，因为已确认 DMA 不忙)
    memcpy(s_DmaTxBuf, data, len);
    
    // 3. 启动 DMA
    DMA_Cmd(DMA1_Channel2, DISABLE);
    DMA1_Channel2->CNDTR = len;
    DMA_Cmd(DMA1_Channel2, ENABLE);
    
    OSAL_ExitCritical();
    
    return len;
}

// ============================================================
//                    4. 接收接口 (RX)
// ============================================================

uint16_t LoRa_Port_ReceiveData(uint8_t *buf, uint16_t max_len) {
    uint16_t cnt = 0;
    // 获取 DMA 当前写入位置 (硬件指针)
    uint16_t dma_write_idx = PORT_DMA_RX_BUF_SIZE - DMA_GetCurrDataCounter(DMA1_Channel3);
    
    // 循环读取直到追上硬件指针
    while (s_RxReadIndex != dma_write_idx && cnt < max_len) {
        buf[cnt++] = s_DmaRxBuf[s_RxReadIndex++];
        if (s_RxReadIndex >= PORT_DMA_RX_BUF_SIZE) s_RxReadIndex = 0;
    }
    return cnt;
}

void LoRa_Port_ClearRxBuffer(void) {
    s_RxReadIndex = PORT_DMA_RX_BUF_SIZE - DMA_GetCurrDataCounter(DMA1_Channel3);
}

// ============================================================
//                    5. 其他能力
// ============================================================

uint32_t LoRa_Port_GetEntropy32(void) {
    // 简单的 ADC 悬空采样 (保持原逻辑)
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOA, ENABLE);
    RCC_ADCCLKConfig(RCC_PCLK2_Div6); 
    
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    
    ADC_InitTypeDef ADC_InitStructure;
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
    ADC_InitStructure.ADC_ScanConvMode = DISABLE;
    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
    ADC_InitStructure.ADC_NbrOfChannel = 1;
    ADC_Init(ADC1, &ADC_InitStructure);
    
    ADC_Cmd(ADC1, ENABLE);
    ADC_ResetCalibration(ADC1);
    while(ADC_GetResetCalibrationStatus(ADC1));
    ADC_StartCalibration(ADC1);
    while(ADC_GetCalibrationStatus(ADC1));
    
    uint32_t seed = 0;
    for(int i=0; i<32; i++) {
        ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_1Cycles5);
        ADC_SoftwareStartConvCmd(ADC1, ENABLE);
        while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC));
        if (ADC_GetConversionValue(ADC1) & 0x01) seed |= (1 << i);
    }
    ADC_Cmd(ADC1, DISABLE);
    
    if (seed == 0) seed = OSAL_GetTick() ^ 0x5A5A5A5A;
    return seed;
}

// ============================================================
//                    6. 中断服务函数
// ============================================================

// DMA TX 完成
void DMA1_Channel2_IRQHandler(void) {
    if (DMA_GetITStatus(DMA1_IT_TC2)) {
        DMA_ClearITPendingBit(DMA1_IT_TC2);
        s_TxDmaBusy = false;
    }
}

```
</file>
<file path="LoRa_Plat\2_Driver\lora_at_command_engine.c">
```c
/**
  ******************************************************************************
  * @file    lora_at_command_engine.c
  * @author  LoRaPlat Team
  * @brief   AT 指令执行引擎实现 (阻塞版)
  ******************************************************************************
  */

#include "lora_at_command_engine.h"
#include "lora_port.h"
#include "lora_osal.h"
#include <string.h>
#include <stdio.h>

// 内部接收缓冲区
static char s_AtRxBuf[128];
static uint16_t s_AtRxIdx = 0;

void LoRa_AT_Init(void) {
    s_AtRxIdx = 0;
    LoRa_Port_ClearRxBuffer();
}

AT_Status_t LoRa_AT_Execute(const char *cmd, const char *expect, uint32_t timeout) {
    // 1. 清空接收缓存
    LoRa_Port_ClearRxBuffer();
    s_AtRxIdx = 0;
    memset(s_AtRxBuf, 0, sizeof(s_AtRxBuf));
    
    // 2. 发送指令
    // 注意：这里调用 Port 层的发送接口
    // 如果 Port 忙，我们需要等待吗？是的，因为这是阻塞接口。
    uint32_t start = OSAL_GetTick();
    while (LoRa_Port_IsTxBusy()) {
        if (OSAL_GetTick() - start > 100) return AT_STATUS_ERROR; // 发送超时
    }
    
    LoRa_Port_TransmitData((const uint8_t*)cmd, strlen(cmd));
    
    // 3. 等待响应
    start = OSAL_GetTick();
    
    while (OSAL_GetTick() - start < timeout) {
        uint8_t byte;
        // 逐字节读取
        if (LoRa_Port_ReceiveData(&byte, 1) > 0) {
            s_AtRxBuf[s_AtRxIdx++] = byte;
            if (s_AtRxIdx >= sizeof(s_AtRxBuf) - 1) s_AtRxIdx = sizeof(s_AtRxBuf) - 2; // 防止溢出
            s_AtRxBuf[s_AtRxIdx] = '\0'; // 保持字符串结尾
            
            // 检查是否包含期望的字符串
            if (strstr(s_AtRxBuf, expect)) {
                OSAL_DelayMs(20); // 稍作延时确保后续字符发完
                return AT_STATUS_OK;
            }
        }
    }
    
    return AT_STATUS_TIMEOUT;
}

```
</file>
<file path="LoRa_Plat\2_Driver\lora_at_command_engine.h">
```h
/**
  ******************************************************************************
  * @file    lora_at_command_engine.h
  * @author  LoRaPlat Team
  * @brief   AT 指令执行引擎接口
  ******************************************************************************
  */

#ifndef __LORA_AT_COMMAND_ENGINE_H
#define __LORA_AT_COMMAND_ENGINE_H

#include <stdint.h>
#include <stdbool.h>

// ============================================================
//                    1. 状态定义
// ============================================================

typedef enum {
    AT_STATUS_OK = 0,       // 执行成功 (收到预期响应)
    AT_STATUS_TIMEOUT,      // 超时 (未收到预期响应)
    AT_STATUS_ERROR,        // 错误 (硬件错误或收到 ERROR)
    AT_STATUS_BUSY          // 忙 (仅异步模式使用)
} AT_Status_t;

// ============================================================
//                    2. 核心接口
// ============================================================

/**
 * @brief  初始化 AT 引擎
 */
void LoRa_AT_Init(void);

/**
 * @brief  执行 AT 指令 (阻塞式)
 * @param  cmd: 指令字符串 (必须以 \r\n 结尾)
 * @param  expect: 期望收到的响应子串 (e.g. "OK")
 * @param  timeout: 超时时间 (ms)
 * @return 执行结果
 */
AT_Status_t LoRa_AT_Execute(const char *cmd, const char *expect, uint32_t timeout);

#endif // __LORA_AT_COMMAND_ENGINE_H

```
</file>
<file path="LoRa_Plat\2_Driver\lora_driver.c">
```c
#include "lora_driver.h"
#include "lora_port.h"

// Init 在 core 中实现，这里只实现透传接口

bool LoRa_Driver_AsyncSend(const uint8_t *data, uint16_t len) {
    // 1. 检查 AUX
    if (LoRa_Port_GetAUX()) return false;
    
    // 2. 启动 DMA
    return (LoRa_Port_TransmitData(data, len) > 0);
}

uint16_t LoRa_Driver_Read(uint8_t *buf, uint16_t max_len) {
    return LoRa_Port_ReceiveData(buf, max_len);
}

bool LoRa_Driver_IsBusy(void) {
    return LoRa_Port_GetAUX() || LoRa_Port_IsTxBusy();
}

```
</file>
<file path="LoRa_Plat\2_Driver\lora_driver.h">
```h
#ifndef __LORA_DRIVER_H
#define __LORA_DRIVER_H

#include "LoRaPlatConfig.h"
#include <stdbool.h>
#include <stdint.h>

/**
 * @brief  驱动初始化 (阻塞式)
 */
bool LoRa_Driver_Init(const LoRa_Config_t *cfg);

/**
 * @brief  异步发送数据 (非阻塞)
 * @return true=已启动DMA, false=忙或错误
 */
bool LoRa_Driver_AsyncSend(const uint8_t *data, uint16_t len);

/**
 * @brief  读取接收数据
 */
uint16_t LoRa_Driver_Read(uint8_t *buf, uint16_t max_len);

/**
 * @brief  查询驱动是否忙碌
 */
bool LoRa_Driver_IsBusy(void);

#endif // __LORA_DRIVER_H

```
</file>
<file path="LoRa_Plat\2_Driver\lora_driver_config.c">
```c
#include "lora_driver.h"
#include <stdio.h>

// --- ATK-LORA-01 指令集 ---

const char* Drv_GetAtCmd_Reset(void) {
    return "AT+RESET\r\n";
}

const char* Drv_GetAtCmd_Mode(uint8_t mode) {
    // 0=透传, 1=定向
    return (mode == 0) ? "AT+TMODE=0\r\n" : "AT+TMODE=1\r\n";
}

void Drv_GetAtCmd_Rate(uint8_t channel, uint8_t rate, char *buf) {
    // 映射速率: 0->0.3k ... 5->19.2k
    // ATK 默认 5 (19.2k)
    if (rate > 5) rate = 5;
    sprintf(buf, "AT+WLRATE=%d,%d\r\n", channel, rate);
}

void Drv_GetAtCmd_Addr(uint16_t addr, char *buf) {
    sprintf(buf, "AT+ADDR=%02X,%02X\r\n", (addr >> 8) & 0xFF, addr & 0xFF);
}

void Drv_GetAtCmd_Power(uint8_t power, char *buf) {
    // 0=11dBm, 1=14dBm, 2=17dBm, 3=20dBm
    if (power > 3) power = 3;
    sprintf(buf, "AT+TPOWER=%d\r\n", power);
}

```
</file>
<file path="LoRa_Plat\2_Driver\lora_driver_core.c">
```c
/**
  ******************************************************************************
  * @file    lora_driver_core.c
  * @author  LoRaPlat Team
  * @brief   LoRa 驱动核心逻辑 (策略层)
  ******************************************************************************
  */

#include "lora_driver.h"
#include "lora_at_command_engine.h"
#include "lora_port.h"
#include "lora_osal.h"
#include <stdio.h>

// ATK-LORA-01 硬件规定：配置模式(MD0=1)下固定使用 115200
#define ATK_LORA_CONFIG_BAUDRATE    115200

// 辅助：波特率转参数
static int _GetBaudParam(uint32_t baudrate) {
    switch(baudrate) {
        case 1200:   return 0;
        case 2400:   return 1;
        case 4800:   return 2;
        case 9600:   return 3;
        case 19200:  return 4;
        case 38400:  return 5;
        case 57600:  return 6;
        case 115200: return 7;
        default:     return 3; 
    }
}

bool LoRa_Driver_Init(const LoRa_Config_t *cfg) {
    // 1. 端口底层初始化
    LoRa_Port_Init(ATK_LORA_CONFIG_BAUDRATE); 
    LoRa_AT_Init();
    
    LORA_LOG("[DRV] Init Start. Target Baud: %d\r\n", LORA_TARGET_BAUDRATE);

    // 2. 进入配置模式
    LoRa_Port_SetMD0(true);
    OSAL_DelayMs(600); 
    
    // 3. 强制 MCU 串口切换到 115200
    LoRa_Port_ReInitUart(ATK_LORA_CONFIG_BAUDRATE);
    OSAL_DelayMs(100); 
    
    // 4. 握手检查
    bool link_ok = false;
    for (int i = 0; i < 3; i++) {
        if (LoRa_AT_Execute("AT\r\n", "OK", 200) == AT_STATUS_OK) {
            link_ok = true;
            LORA_LOG("[DRV] Handshake OK\r\n");
            break;
        }
        OSAL_DelayMs(100);
    }
    
    if (!link_ok) {
        LORA_LOG("[DRV] Handshake Fail!\r\n");
        LoRa_Port_ReInitUart(LORA_TARGET_BAUDRATE);
        return false;
    }
    
    // 5. 应用配置参数
    char cmd[64];
    bool cfg_ok = true;
    
    // 5.1 设置地址
    sprintf(cmd, "AT+ADDR=%02X,%02X\r\n", (cfg->hw_addr >> 8) & 0xFF, cfg->hw_addr & 0xFF);
    if (LoRa_AT_Execute(cmd, "OK", 500) != AT_STATUS_OK) cfg_ok = false;
    
    // 5.2 设置空速和信道
    sprintf(cmd, "AT+WLRATE=%d,%d\r\n", cfg->channel, cfg->air_rate);
    if (LoRa_AT_Execute(cmd, "OK", 500) != AT_STATUS_OK) cfg_ok = false;
    
    // 5.3 设置功率
    sprintf(cmd, "AT+TPOWER=%d\r\n", cfg->power);
    if (LoRa_AT_Execute(cmd, "OK", 500) != AT_STATUS_OK) cfg_ok = false;
    
    // 5.4 设置传输模式
    const char *mode_cmd = (cfg->tmode == 0) ? "AT+TMODE=0\r\n" : "AT+TMODE=1\r\n";
    if (LoRa_AT_Execute(mode_cmd, "OK", 500) != AT_STATUS_OK) cfg_ok = false;

    // 5.5 设置波特率
    int baud_param = _GetBaudParam(LORA_TARGET_BAUDRATE);
    sprintf(cmd, "AT+UART=%d,0\r\n", baud_param);
    if (LoRa_AT_Execute(cmd, "OK", 500) != AT_STATUS_OK) cfg_ok = false;
    
    // 6. 退出配置模式
    LoRa_Port_SetMD0(false);
    LORA_LOG("[DRV] Exiting Config Mode...\r\n");
    
    // 7. 等待重启
    OSAL_DelayMs(100); 
    uint32_t wait_start = OSAL_GetTick();
    while(!LoRa_Port_GetAUX()) {
         if (OSAL_GetTick() - wait_start > 500) break; 
    }
    wait_start = OSAL_GetTick();
    while(LoRa_Port_GetAUX()) {
        if (OSAL_GetTick() - wait_start > 2000) break;
    }
    
    // 8. 切回目标波特率
    LoRa_Port_ReInitUart(LORA_TARGET_BAUDRATE);
    OSAL_DelayMs(100); 
    
    LoRa_Port_SyncAuxState();
    LoRa_Port_ClearRxBuffer();
    
    return cfg_ok;
}

```
</file>
<file path="LoRa_Plat\3_Manager\lora_manager.c">
```c
#include "lora_manager.h"
#include "lora_manager_fsm.h"
#include "lora_manager_buffer.h"
#include "lora_service.h"
#include <string.h>

// ============================================================
//                    内存优化：共享工作区
// ============================================================
// 定义一个足够大的共享缓冲区，供所有子模块轮流使用
// 大小取 Max(MGR_TX_BUF_SIZE, MGR_RX_BUF_SIZE)
#define SHARED_WORKSPACE_SIZE  512 
static uint8_t s_SharedWorkspace[SHARED_WORKSPACE_SIZE];

static LoRa_OnRxData_t s_OnRx;

void LoRa_Manager_Init(LoRa_OnRxData_t on_rx) {
    s_OnRx = on_rx;
    LoRa_Manager_Buffer_Init();
    LoRa_Manager_FSM_Init();
}

void LoRa_Manager_Run(void) {
    // 1. 从 Port 拉取数据
    LoRa_Manager_Buffer_PullFromPort();
    
    // 2. 解析数据包
    LoRa_Packet_t pkt;
    const LoRa_Config_t *cfg = LoRa_Service_GetConfig();
    
    // 清空结构体，防止脏数据
    memset(&pkt, 0, sizeof(pkt));
    
    // 【优化】传入共享缓冲区
    if (LoRa_Manager_Buffer_GetRxPacket(&pkt, cfg->net_id, cfg->group_id, 
                                        s_SharedWorkspace, SHARED_WORKSPACE_SIZE)) {
        // 3. 交给 FSM 处理 (ACK 逻辑)
        LoRa_Manager_FSM_ProcessRxPacket(&pkt);
        
        // 4. 如果是数据包，回调上层
        if (!pkt.IsAckPacket && s_OnRx) {
            s_OnRx(pkt.Payload, pkt.PayloadLen, pkt.SourceID);
        }
    }
    
    // 5. 运行状态机
    // 【优化】传入共享缓冲区用于 PeekTx
    LoRa_Manager_FSM_Run(s_SharedWorkspace, SHARED_WORKSPACE_SIZE);
}

bool LoRa_Manager_Send(const uint8_t *payload, uint16_t len, uint16_t target_id) {
    // 【优化】Send 也是瞬时操作，可以使用共享缓冲区
    return LoRa_Manager_FSM_Send(payload, len, target_id, s_SharedWorkspace, SHARED_WORKSPACE_SIZE);
}

bool LoRa_Manager_IsBusy(void) {
    return LoRa_Manager_FSM_IsBusy();
}

```
</file>
<file path="LoRa_Plat\3_Manager\lora_manager.h">
```h
#ifndef __LORA_MANAGER_H
#define __LORA_MANAGER_H

#include "LoRaPlatConfig.h"
#include <stdint.h>
#include <stdbool.h>

// 回调定义
typedef void (*LoRa_OnRxData_t)(uint8_t *data, uint16_t len, uint16_t src_id);

// 接口
void LoRa_Manager_Init(LoRa_OnRxData_t on_rx);
void LoRa_Manager_Run(void);
bool LoRa_Manager_Send(const uint8_t *payload, uint16_t len, uint16_t target_id);
bool LoRa_Manager_IsBusy(void);

#endif

```
</file>
<file path="LoRa_Plat\3_Manager\lora_manager_buffer.c">
```c
#include "lora_manager_buffer.h"
#include "lora_ring_buffer.h"
#include "lora_port.h"
#include "LoRaPlatConfig.h"

#include "lora_osal.h"

#include <string.h>

#define TX_QUEUE_SIZE   MGR_TX_BUF_SIZE
#define RX_QUEUE_SIZE   MGR_RX_BUF_SIZE

static uint8_t s_TxBufArr[TX_QUEUE_SIZE];
static uint8_t s_RxBufArr[RX_QUEUE_SIZE];
static LoRa_RingBuffer_t s_TxRing;
static LoRa_RingBuffer_t s_RxRing;

void LoRa_Manager_Buffer_Init(void) {
    LoRa_RingBuffer_Init(&s_TxRing, s_TxBufArr, TX_QUEUE_SIZE);
    LoRa_RingBuffer_Init(&s_RxRing, s_RxBufArr, RX_QUEUE_SIZE);
}

// 【优化】使用外部传入的 scratch_buf，移除内部 static/local 数组
bool LoRa_Manager_Buffer_PushTx(const LoRa_Packet_t *packet, uint8_t tmode, uint8_t channel, 
                                uint8_t *scratch_buf, uint16_t scratch_len) {
    if (!scratch_buf) return false;

    // 1. 序列化到共享缓冲区
    uint16_t len = LoRa_Manager_Protocol_Pack(packet, scratch_buf, scratch_len, tmode, channel);
    if (len == 0) return false;
    
    // 2. 检查队列空间
    if (LoRa_RingBuffer_GetFree(&s_TxRing) < len) return false;
    
    // 3. 写入队列
    LoRa_RingBuffer_Write(&s_TxRing, scratch_buf, len);
    return true;
}

bool LoRa_Manager_Buffer_HasTxData(void) {
    return !LoRa_RingBuffer_IsEmpty(&s_TxRing);
}

// 【优化】直接使用传入的 buffer 作为输出目标
uint16_t LoRa_Manager_Buffer_PeekTx(uint8_t *scratch_buf, uint16_t scratch_len) {
    if (s_TxRing.Count == 0) return 0;
    
    uint16_t len = s_TxRing.Count;
    if (len > scratch_len) len = scratch_len;
    
    uint16_t chunk1 = s_TxRing.Size - s_TxRing.Tail;
    if (len <= chunk1) {
        memcpy(scratch_buf, &s_TxRing.pBuffer[s_TxRing.Tail], len);
    } else {
        memcpy(scratch_buf, &s_TxRing.pBuffer[s_TxRing.Tail], chunk1);
        memcpy(scratch_buf + chunk1, &s_TxRing.pBuffer[0], len - chunk1);
    }
    return len;
}

void LoRa_Manager_Buffer_PopTx(uint16_t len) {
    uint8_t dummy;
    // 简单粗暴的移动指针方式，虽然低效但安全
    for(uint16_t i=0; i<len; i++) {
        LoRa_RingBuffer_Read(&s_TxRing, &dummy, 1);
    }
}

uint16_t LoRa_Manager_Buffer_PullFromPort(void) {
    // 这里可以使用小一点的栈变量，因为是从 DMA 读，通常不会太大
    uint8_t temp_buf[64]; 
    uint16_t total_read = 0;
    
    
    while (1) {
        uint16_t len = LoRa_Port_ReceiveData(temp_buf, sizeof(temp_buf));
        if (len == 0) break;
        
        // [新增] 打印接收到的原始数据
        LORA_HEXDUMP("RX RAW", temp_buf, len);
        
        LoRa_RingBuffer_Write(&s_RxRing, temp_buf, len);
        total_read += len;
    }
    return total_read;
}

// 【优化】使用外部传入的 scratch_buf 进行 Peek 和 Unpack
bool LoRa_Manager_Buffer_GetRxPacket(LoRa_Packet_t *packet, uint16_t local_id, uint16_t group_id,
                                     uint8_t *scratch_buf, uint16_t scratch_len) {
    if (LoRa_RingBuffer_IsEmpty(&s_RxRing)) return false;
    
    uint16_t count = LoRa_RingBuffer_GetCount(&s_RxRing);
    if (count > scratch_len) count = scratch_len; // 保护防止溢出
    
    // 1. 偷看所有数据 (Peek) 到共享缓冲区
    uint16_t chunk1 = s_RxRing.Size - s_RxRing.Tail;
    if (count <= chunk1) {
        memcpy(scratch_buf, &s_RxRing.pBuffer[s_RxRing.Tail], count);
    } else {
        memcpy(scratch_buf, &s_RxRing.pBuffer[s_RxRing.Tail], chunk1);
        memcpy(scratch_buf + chunk1, &s_RxRing.pBuffer[0], count - chunk1);
    }
    
    // 2. 尝试解析
    uint16_t consumed = LoRa_Manager_Protocol_Unpack(scratch_buf, count, packet, local_id, group_id);
    
    // 3. 如果消耗了数据，从 RingBuffer 移除
    if (consumed > 0) {
        uint8_t dummy;
        for(uint16_t i=0; i<consumed; i++) {
            LoRa_RingBuffer_Read(&s_RxRing, &dummy, 1);
        }
        
        // 只有当 packet 被有效填充时才返回 true
        // 简单的判断依据：如果是 ACK 包，或者 PayloadLen > 0
        // 注意：Protocol_Unpack 内部如果 CRC 错误会返回 consumed 但不填充 packet
        // 所以这里需要调用者保证 packet 初始为 0，并检查关键字段
        return (packet->IsAckPacket || packet->PayloadLen > 0);
    }
    
    return false;
}

```
</file>
<file path="LoRa_Plat\3_Manager\lora_manager_buffer.h">
```h
/**
  ******************************************************************************
  * @file    lora_manager_buffer.h
  * @author  LoRaPlat Team
  * @brief   LoRa 收发缓冲区管理接口
  ******************************************************************************
  */

#ifndef __LORA_MANAGER_BUFFER_H
#define __LORA_MANAGER_BUFFER_H

#include <stdint.h>
#include <stdbool.h>
#include "lora_manager_protocol.h"

// ============================================================
//                    1. 初始化
// ============================================================

/**
 * @brief  初始化收发缓冲区
 */
void LoRa_Manager_Buffer_Init(void);

// ============================================================
//                    2. 发送队列 (TX Queue)
// ============================================================

/**
 * @brief  将数据包推入发送队列
 * @param  packet: 待发送的数据包结构体
 * @param  tmode: 传输模式
 * @param  channel: 信道
 * @param  scratch_buf: 外部传入的共享缓冲区
 * @param  scratch_len: 缓冲区长度
 * @return true=成功入队, false=队列满
 */
bool LoRa_Manager_Buffer_PushTx(const LoRa_Packet_t *packet, uint8_t tmode, uint8_t channel, 
                                uint8_t *scratch_buf, uint16_t scratch_len);

/**
 * @brief  检查发送队列是否有数据
 * @return true=有数据, false=空
 */
// 【关键修复】之前可能漏掉了这一行声明
bool LoRa_Manager_Buffer_HasTxData(void);

/**
 * @brief  从发送队列头部预览数据 (Peek)
 * @param  scratch_buf: 输出缓冲区
 * @param  scratch_len: 缓冲区大小
 * @return 数据长度
 */
uint16_t LoRa_Manager_Buffer_PeekTx(uint8_t *scratch_buf, uint16_t scratch_len);

/**
 * @brief  从发送队列移除已发送的数据 (Pop)
 * @param  len: 要移除的长度
 */
void LoRa_Manager_Buffer_PopTx(uint16_t len);

// ============================================================
//                    3. 接收处理 (RX Buffer)
// ============================================================

/**
 * @brief  从 Port 层拉取数据并推入 RX RingBuffer
 * @return 拉取到的字节数
 */
uint16_t LoRa_Manager_Buffer_PullFromPort(void);

/**
 * @brief  尝试从 RX RingBuffer 解析一个完整包
 * @param  packet: 输出结构体
 * @param  local_id: 本地 ID
 * @param  group_id: 组 ID
 * @param  scratch_buf: 外部传入的共享缓冲区
 * @param  scratch_len: 缓冲区长度
 * @return true=解析成功, false=无完整包
 */
bool LoRa_Manager_Buffer_GetRxPacket(LoRa_Packet_t *packet, uint16_t local_id, uint16_t group_id,
                                     uint8_t *scratch_buf, uint16_t scratch_len);

#endif // __LORA_MANAGER_BUFFER_H

```
</file>
<file path="LoRa_Plat\3_Manager\lora_manager_fsm.c">
```c
/**
  ******************************************************************************
  * @file    lora_manager_fsm.c
  * @author  LoRaPlat Team
  * @brief   LoRa 协议状态机实现 (V3.4 严格停等协议版)
  *          1. 修复了发送逻辑，确保在等待 ACK 期间拒绝新数据。
  *          2. 增加了 HexDump 调试打印。
  *          3. 使用共享工作区优化内存。
  ******************************************************************************
  */

#include "lora_manager_fsm.h"
#include "lora_manager_buffer.h"
#include "lora_port.h"
#include "lora_osal.h"
#include "lora_service.h" // 获取 Config
#include <string.h>

// ============================================================
//                    1. 内部状态定义
// ============================================================

typedef struct {
    LoRa_FSM_State_t state;
    uint32_t         timer_start;
    uint8_t          retry_count;
    uint8_t          tx_seq; // 当前发送序号
    
    // 待发送的 ACK 信息上下文
    struct {
        bool     pending;
        uint16_t target_id;
        uint8_t  seq;
    } ack_ctx;
    
} FSM_Context_t;

static FSM_Context_t s_FSM;

// ============================================================
//                    2. 内部辅助函数
// ============================================================

static void _FSM_Reset(void) {
    s_FSM.state = LORA_FSM_IDLE;
    s_FSM.ack_ctx.pending = false;
    s_FSM.retry_count = 0;
}

/**
 * @brief 发送 ACK 包
 * @note  ACK 包也是一种数据包，通过 Buffer 机制发送。
 *        调用此函数后，ACK 被推入队列，状态机切回 IDLE，
 *        Run 函数会在下一次循环中将其发出。
 */
static void _FSM_SendAck(uint8_t *scratch_buf, uint16_t scratch_len) {
    LoRa_Packet_t pkt;
    
    // 清空结构体防止脏数据
    memset(&pkt, 0, sizeof(pkt));
    
    pkt.IsAckPacket = true;
    pkt.NeedAck = false; // ACK 包本身不需要 ACK
    pkt.HasCrc = LORA_ENABLE_CRC;
    pkt.TargetID = s_FSM.ack_ctx.target_id;
    pkt.SourceID = LoRa_Service_GetConfig()->net_id;
    pkt.Sequence = s_FSM.ack_ctx.seq; // 回复对方的序号
    pkt.PayloadLen = 0;
    
    // 推入发送队列 (使用共享缓冲区)
    const LoRa_Config_t *cfg = LoRa_Service_GetConfig();
    LoRa_Manager_Buffer_PushTx(&pkt, cfg->tmode, cfg->channel, scratch_buf, scratch_len);
    
    s_FSM.ack_ctx.pending = false;
}

// ============================================================
//                    3. 核心接口实现
// ============================================================

void LoRa_Manager_FSM_Init(void) {
    _FSM_Reset();
    s_FSM.tx_seq = 0;
}

bool LoRa_Manager_FSM_Send(const uint8_t *payload, uint16_t len, uint16_t target_id,
                           uint8_t *scratch_buf, uint16_t scratch_len) {
    
    // 【关键修复】严格停等协议检查
    // 如果状态机不为空闲（例如正在等待上一包的 ACK），则拒绝发送新数据。
    // 这样保证了上层业务逻辑必须等待底层传输完成。
    if (s_FSM.state != LORA_FSM_IDLE) {
        LORA_LOG("[MGR] Send Reject: Busy (State %d)\r\n", s_FSM.state);
        return false; 
    }

    LoRa_Packet_t pkt;
    memset(&pkt, 0, sizeof(pkt));
    
    pkt.IsAckPacket = false;
    // 广播包 (0xFFFF) 不需要 ACK，否则会导致信道风暴
    pkt.NeedAck = (LORA_ENABLE_ACK && target_id != 0xFFFF); 
    pkt.HasCrc = LORA_ENABLE_CRC;
    pkt.TargetID = target_id;
    pkt.SourceID = LoRa_Service_GetConfig()->net_id;
    pkt.Sequence = ++s_FSM.tx_seq;
    pkt.PayloadLen = len;
    
    // 安全拷贝 Payload
    if (len > LORA_MAX_PAYLOAD_LEN) len = LORA_MAX_PAYLOAD_LEN;
    memcpy(pkt.Payload, payload, len);
    
    const LoRa_Config_t *cfg = LoRa_Service_GetConfig();
    
    // 尝试推入队列
    // 注意：这里返回 true 仅代表入队成功，实际发送由 Run 函数调度
    return LoRa_Manager_Buffer_PushTx(&pkt, cfg->tmode, cfg->channel, scratch_buf, scratch_len);
}

void LoRa_Manager_FSM_ProcessRxPacket(const LoRa_Packet_t *packet) {
    // 1. 如果是 ACK 包
    if (packet->IsAckPacket) {
        if (s_FSM.state == LORA_FSM_WAIT_ACK) {
            // 简单校验：ACK 的 Seq 应该等于我们发的 Seq (这里简化处理，Phase 2 可增强)
            // 只要收到 ACK 就认为成功，复位状态机
            LORA_LOG("[MGR] ACK Recv (Seq %d)\r\n", packet->Sequence);
            _FSM_Reset();
            // TODO: 通知上层发送成功 (Event Callback)
        }
    } 
    // 2. 如果是数据包
    else {
        // 如果对方要求 ACK，且不是广播包 (TargetID != 0xFFFF)
        if (packet->NeedAck && packet->TargetID != 0xFFFF) {
            // 记录需要回复的上下文
            s_FSM.ack_ctx.target_id = packet->SourceID;
            s_FSM.ack_ctx.seq = packet->Sequence;
            s_FSM.ack_ctx.pending = true;
            
            // 进入 ACK 延时状态 (避免半双工冲突)
            s_FSM.state = LORA_FSM_ACK_DELAY;
            s_FSM.timer_start = OSAL_GetTick();
        }
    }
}

void LoRa_Manager_FSM_Run(uint8_t *scratch_buf, uint16_t scratch_len) {
    uint32_t now = OSAL_GetTick();
    
    // --------------------------------------------------------
    // 1. 物理层发送调度 (Physical TX Scheduler)
    // --------------------------------------------------------
    // 【关键修复】只有当状态机处于 IDLE 时，才允许从队列提取新数据发送。
    // 这确保了如果正在等待 ACK，不会发送下一包数据。
    if (s_FSM.state == LORA_FSM_IDLE && LoRa_Manager_Buffer_HasTxData()) {
        
        // 只有当 Port 空闲时才发送
        if (!LoRa_Port_IsTxBusy()) {
            // 使用共享缓冲区 Peek 数据
            uint16_t len = LoRa_Manager_Buffer_PeekTx(scratch_buf, scratch_len);
            
            if (len > 0) {
                // [新增] 打印发送原始数据 (HexDump)
                LORA_HEXDUMP("TX RAW", scratch_buf, len);

                // 尝试启动 DMA 发送
                if (LoRa_Port_TransmitData(scratch_buf, len) > 0) {
                    // 发送成功，从队列移除数据
                    LoRa_Manager_Buffer_PopTx(len);
                    
                    // 触发发送完成事件
                    LoRa_Service_NotifyEvent(LORA_EVENT_MSG_SENT, NULL);
                    
                    // 【关键逻辑】检查是否需要进入等待 ACK 状态
                    // 我们需要解析刚才发出去的包头中的 Ctrl 字节
                    const LoRa_Config_t *cfg = LoRa_Service_GetConfig();
                    
                    // 计算 Ctrl 字节在 buffer 中的偏移量
                    // TMODE=1 (定点): Target(2)+Chan(1) + Head(2)+Len(1)+Ctrl(1)... -> Ctrl在索引 6
                    // TMODE=0 (透传): Head(2)+Len(1)+Ctrl(1)... -> Ctrl在索引 3
                    uint8_t offset = (cfg->tmode == 1) ? 3 : 0;
                    
                    // 安全检查防止越界
                    if (len > offset + 3) {
                        uint8_t ctrl_byte = scratch_buf[offset + 3];
                        
                        // 检查 NeedAck 位 (0x40)
                        if (ctrl_byte & LORA_CTRL_MASK_NEED_ACK) {
                            s_FSM.state = LORA_FSM_WAIT_ACK;
                            s_FSM.timer_start = now;
                            s_FSM.retry_count = 0;
                            LORA_LOG("[MGR] Wait ACK...\r\n");
                        }
                    }
                }
            }
        }
    }
    
    // --------------------------------------------------------
    // 2. 协议层状态机 (Protocol FSM)
    // --------------------------------------------------------
    switch (s_FSM.state) {
        case LORA_FSM_IDLE:
            // 空闲状态，无事可做
            break;
            
        case LORA_FSM_ACK_DELAY:
            // 等待延时结束，发送 ACK
            if (now - s_FSM.timer_start > LORA_ACK_DELAY_MS) {
                if (s_FSM.ack_ctx.pending) {
                    _FSM_SendAck(scratch_buf, scratch_len);
                    LORA_LOG("[MGR] ACK Queued\r\n");
                }
                // 发送 ACK 后回到 IDLE，Run 函数的下一次循环会把 ACK 发出去
                s_FSM.state = LORA_FSM_IDLE;
            }
            break;
            
        case LORA_FSM_WAIT_ACK:
            // 等待对方回复 ACK
            if (now - s_FSM.timer_start > LORA_ACK_TIMEOUT_MS) {
                // 超时处理
                if (s_FSM.retry_count < LORA_MAX_RETRY) {
                    s_FSM.retry_count++;
                    LORA_LOG("[MGR] ACK Timeout, Retry %d\r\n", s_FSM.retry_count);
                    // TODO: 触发重传 (需要 Buffer 支持保留数据，Phase 2 实现)
                    // 目前简化处理：超时直接放弃
                    _FSM_Reset();
                } else {
                    LORA_LOG("[MGR] ACK Failed (Give up)\r\n");
                    _FSM_Reset();
                }
            }
            break;
            
        default:
            _FSM_Reset();
            break;
    }
}

bool LoRa_Manager_FSM_IsBusy(void) {
    return s_FSM.state != LORA_FSM_IDLE;
}

```
</file>
<file path="LoRa_Plat\3_Manager\lora_manager_fsm.h">
```h
/**
  ******************************************************************************
  * @file    lora_manager_fsm.h
  * @author  LoRaPlat Team
  * @brief   LoRa 协议状态机定义
  ******************************************************************************
  */

#ifndef __LORA_MANAGER_FSM_H
#define __LORA_MANAGER_FSM_H

#include <stdint.h>
#include <stdbool.h>
#include "lora_manager_protocol.h"

// ============================================================
//                    1. 状态定义
// ============================================================

typedef enum {
    LORA_FSM_IDLE = 0,      // 空闲
    LORA_FSM_TX_RUNNING,    // 正在发送 (等待硬件完成)
    LORA_FSM_WAIT_ACK,      // 等待 ACK
    LORA_FSM_ACK_DELAY      // 发送 ACK 前的延时
} LoRa_FSM_State_t;

// ============================================================
//                    2. 核心接口
// ============================================================

/**
 * @brief  初始化状态机
 */
void LoRa_Manager_FSM_Init(void);

/**
 * @brief  运行状态机 (周期调用)
 */
// 【修改】增加 scratch_buf 参数
void LoRa_Manager_FSM_Run(uint8_t *scratch_buf, uint16_t scratch_len);

/**
 * @brief  处理接收到的数据包
 * @param  packet: 接收到的包
 */
void LoRa_Manager_FSM_ProcessRxPacket(const LoRa_Packet_t *packet);

/**
 * @brief  请求发送数据
 * @param  payload: 数据
 * @param  len: 长度
 * @param  target_id: 目标ID
 * @return true=成功入队
 */
// 【修改】增加 scratch_buf 参数
bool LoRa_Manager_FSM_Send(const uint8_t *payload, uint16_t len, uint16_t target_id,
                           uint8_t *scratch_buf, uint16_t scratch_len);

/**
 * @brief  查询是否忙碌
 */
bool LoRa_Manager_FSM_IsBusy(void);

#endif // __LORA_MANAGER_FSM_H

```
</file>
<file path="LoRa_Plat\3_Manager\lora_manager_protocol.c">
```c
/**
  ******************************************************************************
  * @file    lora_manager_protocol.c
  * @author  LoRaPlat Team
  * @brief   LoRa 协议封包解包实现
  ******************************************************************************
  */

#include "lora_manager_protocol.h"
#include "lora_crc16.h"
#include <string.h>

// ============================================================
//                    1. 封包实现 (Pack)
// ============================================================

uint16_t LoRa_Manager_Protocol_Pack(const LoRa_Packet_t *packet, 
                                    uint8_t *buffer, 
                                    uint16_t buffer_size,
                                    uint8_t tmode,
                                    uint8_t channel)
{
    if (!packet || !buffer) return 0;
    
    uint16_t idx = 0;
    
    // 1. 定点模式头部 (Target Addr + Channel)
    if (tmode == 1) {
        if (idx + 3 > buffer_size) return 0;
        buffer[idx++] = (uint8_t)(packet->TargetID >> 8);
        buffer[idx++] = (uint8_t)(packet->TargetID & 0xFF);
        buffer[idx++] = channel;
    }
    
    // 2. 协议头 (CM)
    if (idx + 2 > buffer_size) return 0;
    buffer[idx++] = LORA_PROTOCOL_HEAD_0;
    buffer[idx++] = LORA_PROTOCOL_HEAD_1;
    
    // 3. 长度 (Payload Len)
    if (idx + 1 > buffer_size) return 0;
    buffer[idx++] = packet->PayloadLen;
    
    // 4. 控制字 (Ctrl)
    uint8_t ctrl = 0;
    if (packet->IsAckPacket) ctrl |= LORA_CTRL_MASK_TYPE;
    if (packet->NeedAck)     ctrl |= LORA_CTRL_MASK_NEED_ACK;
    if (packet->HasCrc)      ctrl |= LORA_CTRL_MASK_HAS_CRC;
    
    if (idx + 1 > buffer_size) return 0;
    buffer[idx++] = ctrl;
    
    // 5. 序号 (Seq)
    if (idx + 1 > buffer_size) return 0;
    buffer[idx++] = packet->Sequence;
    
    // 6. 地址域 (TargetID + SourceID)
    if (idx + 4 > buffer_size) return 0;
    buffer[idx++] = (uint8_t)(packet->TargetID & 0xFF);
    buffer[idx++] = (uint8_t)(packet->TargetID >> 8);
    buffer[idx++] = (uint8_t)(packet->SourceID & 0xFF);
    buffer[idx++] = (uint8_t)(packet->SourceID >> 8);
    
    // 7. 负载 (Payload)
    if (packet->PayloadLen > 0) {
        if (idx + packet->PayloadLen > buffer_size) return 0;
        memcpy(&buffer[idx], packet->Payload, packet->PayloadLen);
        idx += packet->PayloadLen;
    }
    
    // 8. CRC16 (可选)
    if (packet->HasCrc) {
        if (idx + 2 > buffer_size) return 0;
        // 计算范围：从协议头之后(Length)开始，到 Payload 结束
        // 定点模式下，协议头前面有3字节，协议头本身2字节，所以从 buffer[3+2] 开始算?
        // 不，CRC通常只校验协议帧本身。
        // 协议帧起始位置：tmode==1 ? 3 : 0
        uint16_t frame_start = (tmode == 1) ? 3 : 0;
        // 校验内容：Length(1) + Ctrl(1) + Seq(1) + Addr(4) + Payload(N)
        // 当前 idx 指向 CRC 存放位置
        // 校验长度 = idx - (frame_start + 2)
        // +2 是跳过 CM 头
        
        uint16_t crc_calc_start = frame_start + 2;
        uint16_t crc_len = idx - crc_calc_start;
        
        uint16_t crc = LoRa_CRC16_Calculate(&buffer[crc_calc_start], crc_len);
        buffer[idx++] = (uint8_t)(crc & 0xFF);
        buffer[idx++] = (uint8_t)(crc >> 8);
    }
    
    // 9. 包尾 (\r\n)
    if (idx + 2 > buffer_size) return 0;
    buffer[idx++] = LORA_PROTOCOL_TAIL_0;
    buffer[idx++] = LORA_PROTOCOL_TAIL_1;
    
    return idx;
}

// ============================================================
//                    2. 解包实现 (Unpack)
// ============================================================

uint16_t LoRa_Manager_Protocol_Unpack(const uint8_t *buffer, 
                                      uint16_t length, 
                                      LoRa_Packet_t *packet,
                                      uint16_t local_id,
                                      uint16_t group_id)
{
    // 最小包长：Head(2) + Len(1) + Ctrl(1) + Seq(1) + Addr(4) + Tail(2) = 11字节
    if (length < 11) return 0;
    
    // 1. 寻找包头 (CM)
    if (buffer[0] != LORA_PROTOCOL_HEAD_0 || buffer[1] != LORA_PROTOCOL_HEAD_1) {
        // 如果第一个字节不是头，返回 1，让调用者丢弃 1 字节后重试
        return 1; 
    }
    
    // 2. 解析基础字段
    uint8_t p_len = buffer[2];
    uint8_t ctrl  = buffer[3];
    bool has_crc  = (ctrl & LORA_CTRL_MASK_HAS_CRC);
    
    // 3. 计算预期总长度
    // 基础(9) + Payload(p_len) + CRC(2 if has) + Tail(2)
    // 基础包括：Head(2)+Len(1)+Ctrl(1)+Seq(1)+Addr(4) = 9
    uint16_t expected_len = 9 + p_len + (has_crc ? 2 : 0) + 2;
    
    // 4. 长度检查
    if (expected_len > length) {
        // 数据还不够，返回 0 表示继续等待
        return 0; 
    }
    
    // 5. 包尾检查
    if (buffer[expected_len - 2] != LORA_PROTOCOL_TAIL_0 || 
        buffer[expected_len - 1] != LORA_PROTOCOL_TAIL_1) {
        // 包尾不对，说明这可能不是一个合法的包，或者长度字段被污染
        // 丢弃包头，继续寻找
        return 1;
    }
    
    // 6. CRC 校验
    if (has_crc) {
        // 校验范围：从 Len(buffer[2]) 开始，到 Payload 结束
        // 长度 = expected_len - Head(2) - CRC(2) - Tail(2) = expected_len - 6
        uint16_t calc_len = expected_len - 6;
        uint16_t calc_crc = LoRa_CRC16_Calculate(&buffer[2], calc_len);
        
        uint16_t recv_crc = (uint16_t)buffer[expected_len - 4] | 
                            ((uint16_t)buffer[expected_len - 3] << 8);
                            
        if (calc_crc != recv_crc) {
            // CRC 失败，丢弃整包
            return expected_len; 
        }
    }
    
    // 7. 地址过滤
    uint16_t target = (uint16_t)buffer[5] | ((uint16_t)buffer[6] << 8);
    
    bool accept = (target == local_id) || 
                  (target == 0xFFFF) || 
                  (group_id != 0 && target == group_id);
                  
    if (!accept) {
        // 不是发给我的，丢弃整包
        return expected_len;
    }
    
    // 8. 填充输出结构体
    if (packet) {
        packet->IsAckPacket = (ctrl & LORA_CTRL_MASK_TYPE);
        packet->NeedAck     = (ctrl & LORA_CTRL_MASK_NEED_ACK);
        packet->HasCrc      = has_crc;
        packet->Sequence    = buffer[4];
        packet->TargetID    = target;
        packet->SourceID    = (uint16_t)buffer[7] | ((uint16_t)buffer[8] << 8);
        packet->PayloadLen  = p_len;
        
        if (p_len > 0 && p_len <= LORA_MAX_PAYLOAD_LEN) {
            memcpy(packet->Payload, &buffer[9], p_len);
        }
    }
    
    return expected_len;
}

```
</file>
<file path="LoRa_Plat\3_Manager\lora_manager_protocol.h">
```h
/**
  ******************************************************************************
  * @file    lora_manager_protocol.h
  * @author  LoRaPlat Team
  * @brief   LoRa 协议定义与封包解包接口
  ******************************************************************************
  */

#ifndef __LORA_MANAGER_PROTOCOL_H
#define __LORA_MANAGER_PROTOCOL_H

#include <stdint.h>
#include <stdbool.h>
#include "LoRaPlatConfig.h"

// ============================================================
//                    1. 协议常量定义
// ============================================================
#define LORA_PROTOCOL_HEAD_0     'C'
#define LORA_PROTOCOL_HEAD_1     'M'
#define LORA_PROTOCOL_TAIL_0     '\r'
#define LORA_PROTOCOL_TAIL_1     '\n'

#define LORA_CTRL_MASK_TYPE      0x80 // 1=ACK, 0=Data
#define LORA_CTRL_MASK_NEED_ACK  0x40 // 1=Need ACK
#define LORA_CTRL_MASK_HAS_CRC   0x20 // 1=Has CRC

// 最大负载长度 (根据缓冲区大小估算，预留头部开销)
#define LORA_MAX_PAYLOAD_LEN     200

// ============================================================
//                    2. 数据包结构体
// ============================================================

/**
 * @brief LoRa 逻辑数据包结构
 * @note  这是解包后的结构化数据，不包含 Head/Tail 等物理层字节
 */
typedef struct {
    // --- 控制域 ---
    bool     IsAckPacket;    // 是否为 ACK 包
    bool     NeedAck;        // 是否需要回复 ACK
    bool     HasCrc;         // 是否包含 CRC
    
    // --- 地址域 ---
    uint16_t TargetID;       // 目标 ID
    uint16_t SourceID;       // 源 ID (发送方)
    
    // --- 序号与负载 ---
    uint8_t  Sequence;       // 包序号
    uint8_t  PayloadLen;     // 负载长度
    uint8_t  Payload[LORA_MAX_PAYLOAD_LEN]; // 负载数据
    
} LoRa_Packet_t;

// ============================================================
//                    3. 核心接口
// ============================================================

/**
 * @brief  将结构体打包为字节流 (Serialize)
 * @param  packet: 待发送的数据包结构体
 * @param  buffer: 输出缓冲区
 * @param  buffer_size: 缓冲区最大大小
 * @param  tmode: 当前传输模式 (0=透传, 1=定点) - 影响包头格式
 * @param  channel: 当前信道 (仅定点模式需要)
 * @return 打包后的字节总长度 (0表示失败)
 */
uint16_t LoRa_Manager_Protocol_Pack(const LoRa_Packet_t *packet, 
                                    uint8_t *buffer, 
                                    uint16_t buffer_size,
                                    uint8_t tmode,
                                    uint8_t channel);

/**
 * @brief  尝试从缓冲区解析一个完整数据包 (Deserialize)
 * @param  buffer: 输入数据缓冲区
 * @param  length: 缓冲区有效数据长度
 * @param  packet: 输出解析后的结构体
 * @param  local_id: 本地 ID (用于地址过滤)
 * @param  group_id: 组 ID (用于地址过滤)
 * @return 解析消耗的字节数 (0表示未找到完整包，>0表示成功解析并消耗了多少字节)
 */
uint16_t LoRa_Manager_Protocol_Unpack(const uint8_t *buffer, 
                                      uint16_t length, 
                                      LoRa_Packet_t *packet,
                                      uint16_t local_id,
                                      uint16_t group_id);

#endif // __LORA_MANAGER_PROTOCOL_H

```
</file>
<file path="LoRa_Plat\4_Service\lora_service.c">
```c
#include "lora_service.h"
#include "lora_service_config.h"
#include "lora_service_command.h"
#include "lora_manager.h"
#include "lora_driver.h" 
#include "lora_port.h" 
#include "lora_osal.h"
#include <string.h>
#include <stdlib.h>

static LoRa_Callback_t g_cb; 
#define CMD_PREFIX "CMD:"

// ============================================================
//                    内部回调适配
// ============================================================

static void _On_Mgr_RxData(uint8_t *data, uint16_t len, uint16_t src_id) {
    // 1. 检查是否为平台指令
    if (len > strlen(CMD_PREFIX) && strncmp((char*)data, CMD_PREFIX, strlen(CMD_PREFIX)) == 0) {
        LoRa_Service_Command_Process((char*)(data + strlen(CMD_PREFIX)));
    } 
    // 2. 否则为业务数据
    else {
        if (g_cb.OnRecvData) {
            LoRa_RxMeta_t meta = { .rssi = -128, .snr = 0 };
            g_cb.OnRecvData(src_id, data, len, &meta);
        }
    }
}

// ============================================================
//                    核心接口实现
// ============================================================

void LoRa_Service_Init(const LoRa_Callback_t *callbacks, uint16_t override_net_id) {
    if (callbacks) g_cb = *callbacks;
    
    // 1. 初始化配置模块
    LoRa_Service_Config_Init();
    
    // 2. 加载 Flash 配置 (如果有)
    if (g_cb.LoadConfig) {
        LoRa_Config_t flash_cfg;
        g_cb.LoadConfig(&flash_cfg);
        if (flash_cfg.magic == LORA_CFG_MAGIC) {
            LoRa_Service_Config_Set(&flash_cfg);
        } else {
            // Flash 无效，保存默认值
            if (g_cb.SaveConfig) g_cb.SaveConfig(LoRa_Service_Config_Get());
        }
    }
    
    // 3. 调试覆盖
    if (override_net_id != 0) {
        LoRa_Config_t temp = *LoRa_Service_Config_Get();
        temp.net_id = override_net_id;
        LoRa_Service_Config_Set(&temp);
    }
    
    // 4. 初始化 Manager
    LoRa_Manager_Init(_On_Mgr_RxData);
    
    // 5. 初始化 Driver (阻塞)
    // 注意：这里依然调用旧的 Drv_Init，Step 4 会替换它
    if (LoRa_Driver_Init(LoRa_Service_Config_Get())) {
        LoRa_Service_NotifyEvent(LORA_EVENT_INIT_SUCCESS, NULL);
    } else {
        while(1); // 死循环报警
    }
}

void LoRa_Service_Run(void) {
    LoRa_Manager_Run();
}

bool LoRa_Service_Send(const uint8_t *data, uint16_t len, uint16_t target_id) {
    return LoRa_Manager_Send(data, len, target_id);
}

void LoRa_Service_FactoryReset(void) {
    LoRa_Service_Config_FactoryReset();
    if (g_cb.SaveConfig) g_cb.SaveConfig(LoRa_Service_Config_Get());
    LoRa_Service_NotifyEvent(LORA_EVENT_FACTORY_RESET, NULL);
    if (g_cb.SystemReset) g_cb.SystemReset();
}

const LoRa_Config_t* LoRa_Service_GetConfig(void) {
    return LoRa_Service_Config_Get();
}

void LoRa_Service_SetConfig(const LoRa_Config_t *cfg) {
    LoRa_Service_Config_Set(cfg);
    if (g_cb.SaveConfig) g_cb.SaveConfig(cfg);
}

void LoRa_Service_NotifyEvent(LoRa_Event_t event, void *arg) {
    if (g_cb.OnEvent) g_cb.OnEvent(event, arg);
}

```
</file>
<file path="LoRa_Plat\4_Service\lora_service.h">
```h
#ifndef __LORA_SERVICE_H
#define __LORA_SERVICE_H

#include "lora_osal.h"
#include "LoRaPlatConfig.h"
#include <stdint.h>
#include <stdbool.h>

// ============================================================
//                    1. 数据结构定义
// ============================================================

typedef struct {
    int16_t rssi; 
    int8_t  snr;  
} LoRa_RxMeta_t;

typedef enum {
    LORA_EVENT_INIT_SUCCESS = 0,
    LORA_EVENT_BIND_SUCCESS,    
    LORA_EVENT_GROUP_UPDATE,    
    LORA_EVENT_CONFIG_START,    
    LORA_EVENT_CONFIG_COMMIT,   
    LORA_EVENT_FACTORY_RESET,   
    LORA_EVENT_REBOOT_REQ,      
    LORA_EVENT_MSG_RECEIVED,    
    LORA_EVENT_MSG_SENT         
} LoRa_Event_t;

// ============================================================
//                    2. 回调接口
// ============================================================
typedef struct {
    void (*SaveConfig)(const LoRa_Config_t *cfg);
    void (*LoadConfig)(LoRa_Config_t *cfg);
    uint32_t (*GetRandomSeed)(void); 
    void (*SystemReset)(void);       
    void (*OnRecvData)(uint16_t src_id, const uint8_t *data, uint16_t len, LoRa_RxMeta_t *meta);
    void (*OnEvent)(LoRa_Event_t event, void *arg);
} LoRa_Callback_t;

// ============================================================
//                    3. 全局函数
// ============================================================

void LoRa_Service_Init(const LoRa_Callback_t *callbacks, uint16_t override_net_id);
void LoRa_Service_Run(void);
bool LoRa_Service_Send(const uint8_t *data, uint16_t len, uint16_t target_id);
void LoRa_Service_FactoryReset(void);

// 配置访问
const LoRa_Config_t* LoRa_Service_GetConfig(void);
void LoRa_Service_SetConfig(const LoRa_Config_t *cfg);

// [新增] 内部通知接口 (供 Command 模块调用)
void LoRa_Service_NotifyEvent(LoRa_Event_t event, void *arg);

#endif // __LORA_SERVICE_H

```
</file>
<file path="LoRa_Plat\4_Service\lora_service_command.c">
```c
/**
  ******************************************************************************
  * @file    lora_service_command.c
  * @author  LoRaPlat Team
  * @brief   LoRa 平台指令解析实现
  ******************************************************************************
  */

#include "lora_service_command.h"
#include "lora_service_config.h"
#include "lora_service.h" // 获取事件通知接口
#include "lora_osal.h"
#include <string.h>
#include <stdio.h>

// ============================================================
//                    1. 核心接口实现
// ============================================================

bool LoRa_Service_Command_Process(char *cmd_str) {
    char *cmd = strtok(cmd_str, "="); 
    char *params = strtok(NULL, "");  

    if (cmd == NULL) return false;

    LORA_LOG("[SVC] Cmd: %s\r\n", cmd);
    
    // 获取当前配置副本
    LoRa_Config_t cfg = *LoRa_Service_Config_Get();
    bool cfg_changed = false;

    // 1. BIND 指令
    if (strcmp(cmd, "BIND") == 0 && params != NULL) {
        uint32_t target_uuid;
        uint16_t new_net_id;
        if (sscanf(params, "%u,%hu", &target_uuid, &new_net_id) == 2) {
            if (target_uuid == cfg.uuid) {
                cfg.net_id = new_net_id;
                cfg_changed = true;
                // 通知 Service 层
                // 这里需要回调，但 Command 模块不直接依赖 Service 回调
                // 解决方案：Command 模块只修改 Config，返回 true。
                // Service 层在调用 Process 后，检查 Config 是否变化？
                // 或者 Command 模块调用 Service 提供的 Notify 接口。
                
                // 暂时策略：直接调用 Service 层的 Notify 接口 (需要 Service.h 暴露)
                // LoRa_Service_NotifyEvent(LORA_EVENT_BIND_SUCCESS, &new_net_id);
            }
        }
    }
    // 2. GROUP 指令
    else if (strcmp(cmd, "GROUP") == 0 && params != NULL) {
        uint16_t new_group_id;
        if (sscanf(params, "%hu", &new_group_id) == 1) {
            cfg.group_id = new_group_id;
            cfg_changed = true;
        }
    }
    // 3. RST 指令
    else if (strcmp(cmd, "RST") == 0) {
        // LoRa_Service_NotifyEvent(LORA_EVENT_REBOOT_REQ, NULL);
        return true;
    }
    // 4. FACTORY 指令
    else if (strcmp(cmd, "FACTORY") == 0) {
        LoRa_Service_Config_FactoryReset();
        return true;
    }
    
    if (cfg_changed) {
        LoRa_Service_Config_Set(&cfg);
        return true;
    }
    
    return false;
}

```
</file>
<file path="LoRa_Plat\4_Service\lora_service_command.h">
```h
/**
  ******************************************************************************
  * @file    lora_service_command.h
  * @author  LoRaPlat Team
  * @brief   LoRa 平台指令解析接口
  ******************************************************************************
  */

#ifndef __LORA_SERVICE_COMMAND_H
#define __LORA_SERVICE_COMMAND_H

#include <stdint.h>
#include <stdbool.h>

// ============================================================
//                    1. 核心接口
// ============================================================

/**
 * @brief  处理平台指令字符串
 * @param  cmd_str: 指令字符串 (e.g. "CMD:BIND=...")
 * @return true=指令已处理, false=未知指令或格式错误
 */
bool LoRa_Service_Command_Process(char *cmd_str);

#endif // __LORA_SERVICE_COMMAND_H

```
</file>
<file path="LoRa_Plat\4_Service\lora_service_config.c">
```c
/**
  ******************************************************************************
  * @file    lora_service_config.c
  * @author  LoRaPlat Team
  * @brief   LoRa 配置管理实现
  ******************************************************************************
  */

#include "lora_service_config.h"
#include "lora_service.h" // 获取回调接口
#include "lora_osal.h"
#include <string.h>
#include <stdlib.h>

// 内部静态配置副本
static LoRa_Config_t s_CurrentConfig;

// ============================================================
//                    1. 内部辅助
// ============================================================

static void _LoadDefaults(void) {
    memset(&s_CurrentConfig, 0, sizeof(LoRa_Config_t));
    
    s_CurrentConfig.magic    = LORA_CFG_MAGIC;
    s_CurrentConfig.token    = DEFAULT_LORA_TOKEN;
    s_CurrentConfig.net_id   = LORA_ID_UNASSIGNED;
    s_CurrentConfig.group_id = LORA_GROUP_ID_DEFAULT; 
    s_CurrentConfig.hw_addr  = LORA_HW_ADDR_DEFAULT;
    s_CurrentConfig.channel  = DEFAULT_LORA_CHANNEL;
    s_CurrentConfig.power    = (uint8_t)DEFAULT_LORA_POWER;
    s_CurrentConfig.air_rate = (uint8_t)DEFAULT_LORA_RATE;
    s_CurrentConfig.tmode    = (uint8_t)DEFAULT_LORA_TMODE;
    
    // 生成随机 UUID
    //uint32_t seed = 0;
    // 这里需要回调获取种子，但 Config 模块不直接依赖回调
    // 我们假设 Service 层初始化时已经设置了回调
    // 或者通过 OSAL 获取？
    // 暂时策略：使用 OSAL_GetTick 作为简单种子，或者由 Service 层传入
    // 为了解耦，我们假设 Service 层会在 Init 后再次调用 SetConfig 来修正 UUID
    s_CurrentConfig.uuid = 0; 
}

// ============================================================
//                    2. 核心接口实现
// ============================================================

void LoRa_Service_Config_Init(void) {
    _LoadDefaults();
    
#if (defined(LORA_ENABLE_FLASH_SAVE) && LORA_ENABLE_FLASH_SAVE == 1)
    // 尝试从 Flash 加载
    // 这里需要回调函数，但 Config 模块不知道回调在哪里
    // 解决方案：Service 层初始化时，将回调传递给 Config 模块？
    // 或者 Config 模块暴露一个 SetCallbacks 接口？
    // 简单起见，我们假设 Service 层负责调用 Load/Save，Config 模块只负责管理内存副本。
    
    // 修正设计：Config 模块应该只管理内存副本。Flash 读写由 Service 层协调。
    // 但为了封装，我们可以在 Service 层把回调传进来。
    
    // 暂时策略：Config 模块不直接调用 Flash 接口，而是提供 Load/Save 辅助函数供 Service 层调用。
    // 这样 Config 模块就纯粹了。
#endif
}

const LoRa_Config_t* LoRa_Service_Config_Get(void) {
    return &s_CurrentConfig;
}

void LoRa_Service_Config_Set(const LoRa_Config_t *cfg) {
    if (cfg) {
        OSAL_EnterCritical();
        memcpy(&s_CurrentConfig, cfg, sizeof(LoRa_Config_t));
        OSAL_ExitCritical();
    }
}

void LoRa_Service_Config_FactoryReset(void) {
    _LoadDefaults();
    s_CurrentConfig.magic = 0; // 标记为无效，下次上电会重置
}

```
</file>
<file path="LoRa_Plat\4_Service\lora_service_config.h">
```h
/**
  ******************************************************************************
  * @file    lora_service_config.h
  * @author  LoRaPlat Team
  * @brief   LoRa 配置管理接口
  ******************************************************************************
  */

#ifndef __LORA_SERVICE_CONFIG_H
#define __LORA_SERVICE_CONFIG_H

#include "LoRaPlatConfig.h"
#include <stdint.h>
#include <stdbool.h>

// ============================================================
//                    1. 核心接口
// ============================================================

/**
 * @brief  初始化配置模块
 * @note   优先加载 Flash，若无效则使用默认值
 */
void LoRa_Service_Config_Init(void);

/**
 * @brief  获取当前配置 (只读)
 */
const LoRa_Config_t* LoRa_Service_Config_Get(void);

/**
 * @brief  更新配置并保存到 Flash
 * @param  cfg: 新配置
 */
void LoRa_Service_Config_Set(const LoRa_Config_t *cfg);

/**
 * @brief  恢复出厂设置 (清除 Flash)
 */
void LoRa_Service_Config_FactoryReset(void);

#endif // __LORA_SERVICE_CONFIG_H

```
</file>
<file path="User\lora_demo_osal.c">
```c
/**
  ******************************************************************************
  * @file    lora_demo_osal.c
  * @author  LoRaPlat Team
  * @brief   OSAL 接口适配层 (STM32F103 裸机版)
  ******************************************************************************
  */

#include "lora_osal.h"
#include "Delay.h"      // 硬件延时实现
#include "Serial.h"     // 硬件串口实现
#include "stm32f10x.h"  // 用于开关中断
#include <stdio.h>
#include <stdarg.h>

// ============================================================
//                    1. 接口适配实现
// ============================================================

// 适配 GetTick
static uint32_t Demo_GetTick(void) {
    return GetTick(); // 来自 System/Delay.c
}

// 适配 DelayMs
static void Demo_DelayMs(uint32_t ms) {
    Delay_ms(ms); // 来自 System/Delay.c
}

// 适配临界区 (关中断)
static void Demo_EnterCritical(void) {
    __disable_irq();
}

// 适配临界区 (开中断)
static void Demo_ExitCritical(void) {
    __enable_irq();
}

// 适配日志打印 (变参处理)
static void Demo_Log(const char *fmt, va_list args) {
    char buf[128];
    // 格式化字符串
    vsnprintf(buf, sizeof(buf), fmt, args);
    // 通过串口发送
    Serial_Printf("%s", buf);
}

// 适配 HexDump (可选，优化性能)
static void Demo_LogHex(const char *tag, const void *data, uint16_t len) {
    Serial_HexDump(tag, (const uint8_t*)data, len);
}

// ============================================================
//                    2. 接口注册结构体
// ============================================================

static const LoRa_OSAL_Interface_t s_OsalImpl = {
    .GetTick       = Demo_GetTick,
    .DelayMs       = Demo_DelayMs,
    .EnterCritical = Demo_EnterCritical,
    .ExitCritical  = Demo_ExitCritical,
    .Log           = Demo_Log,
    .LogHex        = Demo_LogHex, // 注册优化后的 HexDump
    .Malloc        = NULL,        // 裸机不使用动态内存
    .Free          = NULL
};

// ============================================================
//                    3. 公开初始化函数
// ============================================================

/**
 * @brief 在 main.c 中调用此函数以激活 OSAL
 */
void Demo_OSAL_Init(void) {
    // 将本地实现注入到 LoRaPlat 核心
    LoRa_OSAL_Init(&s_OsalImpl);
}

```
</file>
<file path="User\main.c">
```c
/**
  ******************************************************************************
  * @file    main.c
  * @author  LoRaPlat Team
  * @brief   LoRaPlat V3.2 综合测试程序 (适配变量私有化与接口访问)
  ******************************************************************************
  */

#include "stm32f10x.h"
#include "Delay.h"
#include "Serial.h"
#include "LED.h"
#include "Flash.h"
#include "lora_service.h" 
#include "lora_port.h" 
#include <string.h>
#include <stdio.h>


extern void Demo_OSAL_Init(void); 
volatile uint8_t g_TimeoutFlag;

// ============================================================================
// [测试角色配置]
// 1 = HOST (主机): ID=1, Group=100
// 2 = SLAVE (从机): ID=2, Group=100
// ============================================================================
#define TEST_ROLE      2

// ============================================================================
// 1. 接口适配 (Adapter Layer)
// ============================================================================

void Adapter_SaveConfig(const LoRa_Config_t *cfg) {
    Flash_WriteLoRaConfig(cfg);
    Serial_Printf("[APP] Config Saved to Flash.\r\n");
}

void Adapter_LoadConfig(LoRa_Config_t *cfg) {
    Flash_ReadLoRaConfig(cfg);
}

uint32_t Adapter_GetRandomSeed(void) {
    return LoRa_Port_GetEntropy32(); // 使用 ADC 悬空噪声作为种子
}

void Adapter_SystemReset(void) {
    Serial_Printf("[APP] System Resetting...\r\n");
    for(volatile int i=0; i<1000000; i++); 
    NVIC_SystemReset();
}

// 接收数据回调
void Adapter_OnRecvData(uint16_t src_id, const uint8_t *data, uint16_t len, LoRa_RxMeta_t *meta) {
    Serial_Printf("[APP] RX from ID:0x%04X | Len:%d | Payload: %s\r\n", src_id, len, data);
    
    // [安全修正] 使用 strcmp 进行严格匹配，防止 "LED_ON111" 误触发
    // 实际项目中建议定义更严谨的指令格式
    if (strstr((const char*)data, "LED_ON")) {
        LED2_ON(); 
        Serial_Printf("    -> Action: LED ON\r\n");
    } else if (strstr((const char*)data, "LED_OFF")) {
        LED2_OFF();
        Serial_Printf("    -> Action: LED OFF\r\n");
    }

#if (TEST_ROLE == 2)
    // [重要] 自动回响 (Echo) 暂时关闭
    // 原因：当前未实现 TX 队列，Echo 包会与 ACK 包发生 DMA 竞争导致数据损坏。
    // 待 Phase 2 实现 RingBuffer 后再开启。
    /*
    if (src_id != 0xFFFF) {
        char reply[64];
        snprintf(reply, 64, "Echo: %s", data);
        if (!LoRa_Service_Send((uint8_t*)reply, strlen(reply), src_id)) {
            Serial_Printf("[APP] Echo Failed: System Busy\r\n");
        } else {
            Serial_Printf("[APP] Echo Sent\r\n");
        }
    }
    */
#endif
}

// 系统事件回调
void Adapter_OnEvent(LoRa_Event_t event, void *arg) {
    // [修改] 使用接口获取配置，不再直接访问全局变量
    const LoRa_Config_t *cfg = LoRa_Service_GetConfig();

    switch(event) {
        case LORA_EVENT_INIT_SUCCESS:
            Serial_Printf("[EVT] LoRa Init Done.\r\n");
            if (cfg) {
                Serial_Printf("      UUID: 0x%08X\r\n", cfg->uuid);
                Serial_Printf("      NetID: %d (0x%04X)\r\n", cfg->net_id, cfg->net_id);
                Serial_Printf("      Group: %d (0x%04X)\r\n", cfg->group_id, cfg->group_id);
            }
            break;
            
        case LORA_EVENT_MSG_SENT:
            Serial_Printf("[EVT] TX Complete\r\n");
            break;
            
        case LORA_EVENT_MSG_RECEIVED:
            // 收到消息时的 LED 指示（可选）
            // LED2_Turn();
            break;
            
        case LORA_EVENT_BIND_SUCCESS:
            Serial_Printf("[EVT] BIND Success! New ID: %d\r\n", *(uint16_t*)arg);
            break;
            
        case LORA_EVENT_FACTORY_RESET:
            Serial_Printf("[EVT] Factory Reset Triggered.\r\n");
            break;
            
        default: break;
    }
}

// 定义适配器实例
const LoRa_Callback_t my_adapter = {
    .SaveConfig     = Adapter_SaveConfig,
    .LoadConfig     = Adapter_LoadConfig,
    .GetRandomSeed  = Adapter_GetRandomSeed,
    .SystemReset    = Adapter_SystemReset,
    .OnRecvData     = Adapter_OnRecvData,
    .OnEvent        = Adapter_OnEvent
};

// ============================================================================
// 2. 辅助函数
// ============================================================================

void Force_Init_Config(void) {
    LoRa_Config_t cfg;
    // 直接读取 Flash 检查是否需要强制重置测试环境
    Flash_ReadLoRaConfig(&cfg);
    
    uint16_t target_id = (TEST_ROLE == 1) ? 1 : 2;
    uint16_t target_group = 100; 
    
    // 如果 Flash 中的配置与当前测试角色不符，强制重写
    if (cfg.net_id != target_id || cfg.group_id != target_group || cfg.magic != LORA_CFG_MAGIC) {
        Serial_Printf("[TEST] Forcing Config: NetID=%d, GroupID=%d...\r\n", target_id, target_group);
        
        memset(&cfg, 0, sizeof(LoRa_Config_t));
        cfg.magic = LORA_CFG_MAGIC;
        cfg.net_id = target_id;
        cfg.group_id = target_group; 
        // 模拟不同的 UUID
        cfg.uuid = (TEST_ROLE == 1) ? 0xAAAA1111 : 0xBBBB2222;
        cfg.hw_addr = LORA_HW_ADDR_DEFAULT;
        cfg.channel = DEFAULT_LORA_CHANNEL;
        cfg.power = DEFAULT_LORA_POWER;
        cfg.air_rate = DEFAULT_LORA_RATE;
        cfg.tmode = DEFAULT_LORA_TMODE;
        
        Flash_WriteLoRaConfig(&cfg);
        Serial_Printf("[TEST] Force Init Done. Rebooting...\r\n");
        Adapter_SystemReset();
    }
}

void Show_Help(void) {
    Serial_Printf("\r\n=== LoRaPlat V3.2 Refactored Test ===\r\n");
    Serial_Printf("Role: %s (ID=%d, Group=%d)\r\n", (TEST_ROLE==1)?"HOST":"SLAVE", 
           (TEST_ROLE==1)?1:2, 100);
    Serial_Printf("Commands (Type in Serial):\r\n");
    Serial_Printf("  CMD <id> <msg>  : Unicast (e.g., CMD 2 LED_ON)\r\n");
    Serial_Printf("  CMD 100 <msg>   : Multicast to Group 100\r\n");
    Serial_Printf("  CMD 65535 <msg> : Broadcast\r\n");
    Serial_Printf("  BIND <uuid> <id>: Remote Bind ID\r\n");
    Serial_Printf("Note: LED1 blinks fast (10Hz) to prove system is NON-BLOCKING.\r\n");
    Serial_Printf("====================================\r\n");
}

// ============================================================================
// 3. 主函数
// ============================================================================

int main(void)
{
    // 1. 基础硬件初始化
    SysTick_Init();
    LED_Init();
    Serial_Init();
    
    // 2. OSAL 初始化 (如果需要显式初始化，视具体实现而定)
    // extern void Demo_OSAL_Init(void); 
    Demo_OSAL_Init();
    
    // 3. 检查并强制配置测试环境 (仅用于测试阶段)
    Force_Init_Config();
	
		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    
    Show_Help();

    // 4. 初始化 LoRa 服务 (阻塞式，包含驱动握手)
    // 传入适配器和 0 (不强制覆盖 NetID，使用 Flash/默认值)
    LoRa_Service_Init(&my_adapter, 0); 

    uint32_t last_blink = 0;
		
#if (TEST_ROLE == 1)
    char input_buf[128]; // 串口接收缓冲区
#endif

    while (1)
    {
        // ----------------------------------------------------
        // 1. 协议栈心跳 (必须周期性调用)
        // ----------------------------------------------------
        LoRa_Service_Run();

        // ----------------------------------------------------
        // 2. 业务逻辑: 串口透传 (仅主机)
        // ----------------------------------------------------
#if (TEST_ROLE == 1)
        // [修改] 使用 Serial_GetRxPacket 接口获取数据，替代直接访问全局变量
        if (Serial_GetRxPacket(input_buf, sizeof(input_buf)))
        {
            char *input = input_buf;
            int len = strlen(input);
            
            // 去除末尾换行符
            while(len > 0 && (input[len-1] == '\r' || input[len-1] == '\n')) input[--len] = '\0';

            if (len > 0) {
                Serial_Printf("[PC] Input: %s\r\n", input);
                
                // 解析 CMD 指令
                if (strncmp(input, "CMD ", 4) == 0) {
                    int target_id;
                    char msg[64];
                    if (sscanf(input + 4, "%d %[^\n]", &target_id, msg) == 2) {
                        Serial_Printf(" -> Sending to %d: %s\r\n", target_id, msg);
                        if (!LoRa_Service_Send((uint8_t*)msg, strlen(msg), target_id)) {
                            Serial_Printf("[APP] Error: System Busy!\r\n");
                        }
                    }
                }
                // 解析 BIND 指令
                else if (strncmp(input, "BIND ", 5) == 0) {
                    uint32_t u;
                    int id;
                    if (sscanf(input + 5, "%u %d", &u, &id) == 2) {
                        char cmd[64];
                        sprintf(cmd, "CMD:BIND=%u,%d", u, id);
                        Serial_Printf(" -> Sending Bind: %s\r\n", cmd);
                        // 发送广播包
                        LoRa_Service_Send((uint8_t*)cmd, strlen(cmd), 0xFFFF); 
                    }
                }
            }
        }
#endif

        // ----------------------------------------------------
        // 3. 验证非阻塞特性: LED 心跳
        // ----------------------------------------------------
        if (GetTick() - last_blink > 50) { 
            last_blink = GetTick();
            LED1_Turn(); 
        }
    }
}

```
</file>
</project_files>