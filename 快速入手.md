## 2. 快速入门 (Quick Start)

本章将指导您在 10 分钟内搭建起 LoRaPlat 的测试环境，并完成主机与从机的首次通信。

### 2.1 硬件准备

您需要准备两套 STM32 开发板与 LoRa 模块：

*   **主机 (Host):** 用于发送指令，需连接 PC 查看日志。
    *   1x STM32F103C8T6 核心板
    *   1x ATK-LORA-01 模块
    *   1x USB-TTL 串口模块 (连接 STM32 的 PA9/PA10)
*   **从机 (Slave):** 用于接收指令并执行动作。
    *   1x STM32F103C8T6 核心板
    *   1x ATK-LORA-01 模块
    *   (可选) 1x LED 灯 (连接 PA1，低电平点亮)

**接线说明 (主机与从机一致):**

| STM32 引脚 | LoRa 模块引脚 | 功能说明 |
| :--- | :--- | :--- |
| **PB10** | RXD | 串口发送 (TX -> RX) |
| **PB11** | TXD | 串口接收 (RX <- TX) |
| **PA4** | MD0 | 模式控制 |
| **PA5** | AUX | 状态指示 |
| **3.3V** | VCC | 电源 (严禁接 5V) |
| **GND** | GND | 地 |

### 2.2 软件配置与烧录

项目代码中内置了自动化测试逻辑，通过修改宏定义即可切换角色。

1.  **打开工程:** 使用 Keil 5 打开 `Project.uvprojx`。
2.  **配置主机代码:**
    *   打开 `User/main.c`。
    *   修改宏定义为：`#define TEST_ROLE 1`。
    *   编译并下载到 **主机** 开发板。
3.  **配置从机代码:**
    *   打开 `User/main.c`。
    *   修改宏定义为：`#define TEST_ROLE 2`。
    *   编译并下载到 **从机** 开发板。

> **注意:** 首次烧录后，系统会自动执行 `Force_Init_Config`，将主机 ID 初始化为 1，从机 ID 初始化为 2，组 ID 均为 100。

### 2.3 运行测试

1.  **连接串口:** 将主机的 USB-TTL 插入电脑，打开串口调试助手（如 XCOM）。
    *   波特率: **115200**
    *   停止位: 1
    *   校验位: None
    *   **关键设置:** 勾选 "发送新行" (Send New Line / \r\n)。
2.  **复位设备:** 按下主机和从机的复位键。主机串口应打印启动日志。
3.  **发送测试指令:**
    *   在串口助手发送: `CMD 2 LED_ON`
    *   **现象:** 从机板载 LED 点亮，主机收到 ACK 并打印 `[EVT] MSG_SENT`。
    *   在串口助手发送: `CMD 2 LED_OFF`
    *   **现象:** 从机板载 LED 熄灭。
4.  **测试组播:**
    *   在串口助手发送: `CMD 100 LED_ON`
    *   **现象:** 从机 LED 点亮（因为从机默认在 Group 100）。

恭喜！您已成功跑通了 LoRaPlat 的基础通信链路。


---
占位符
---

---
## 4. API 参考手册 (API Reference)

本章详细介绍了 LoRaPlat 核心服务层 (`lora_service.h`) 的接口与指令集。

### 4.1 核心函数

#### `LoRa_Service_Init`
初始化 LoRa 服务层，启动协议栈与硬件驱动。

*   **原型:** `void LoRa_Service_Init(const LoRa_Callback_t *callbacks, uint16_t override_net_id)`
*   **参数:**
    *   `callbacks`: 指向用户回调结构体的指针（见 4.2 节）。
    *   `override_net_id`: 调试用。传入非 0 值可强制覆盖 Flash 中的 NetID；传入 0 则使用 Flash 配置。
*   **示例:**
    ```c
    LoRa_Service_Init(&my_callbacks, 0);
    ```

#### `LoRa_Service_Run`
服务层主循环，驱动协议栈状态机。**必须在 main 循环中持续调用。**

*   **原型:** `void LoRa_Service_Run(void)`
*   **注意:** 该函数是非阻塞的，但请勿在回调函数中执行耗时操作，以免阻塞状态机。

#### `LoRa_Service_Send`
发送应用层数据。

*   **原型:** `bool LoRa_Service_Send(const uint8_t *data, uint16_t len, uint16_t target_id)`
*   **参数:**
    *   `data`: 数据缓冲区指针。
    *   `len`: 数据长度（最大 200 字节）。
    *   `target_id`: 目标设备 ID。
        *   `1~65534`: 单播给特定设备。
        *   `0xFFFF`: 广播给所有设备。
        *   `Group ID`: 组播给特定组（需接收端支持）。
*   **返回值:** `true` 表示成功加入发送队列（或发送成功），`false` 表示发送忙或失败。

---

### 4.2 回调结构体 (`LoRa_Callback_t`)

用户需实现此结构体中的函数，以接入业务逻辑。

| 字段 | 类型 | 说明 |
| :--- | :--- | :--- |
| **OnRecvData** | `void (*)(uint16_t src_id, const uint8_t *data, uint16_t len, LoRa_RxMeta_t *meta)` | **核心回调**。收到业务数据时调用。<br>`src_id`: 发送方 ID。<br>`data`: 纯净的业务数据（已去除协议头）。<br>`meta`: 包含 RSSI 和 SNR 信息。 |
| **OnEvent** | `void (*)(LoRa_Event_t event, void *arg)` | 系统事件通知。用于日志打印或 LED 指示。<br>事件类型见 `LoRa_Event_t` 枚举。 |
| **SaveConfig** | `void (*)(const LoRa_Config_t *cfg)` | 平台请求保存配置到 Flash 时调用。 |
| **LoadConfig** | `void (*)(LoRa_Config_t *cfg)` | 平台请求从 Flash 读取配置时调用。 |
| **GetTick** | `uint32_t (*)(void)` | 提供系统毫秒级时基。 |

---

### 4.3 平台指令集 (Platform Commands)

LoRaPlat 内置了一套管理指令，以 `CMD:` 开头。Service 层会自动拦截并处理这些指令，**不会**触发 `OnRecvData` 回调。

**指令格式:** `CMD:<Command>=<Param1>,<Param2>...`

| 指令 | 格式 | 功能描述 | 示例 |
| :--- | :--- | :--- | :--- |
| **BIND** | `CMD:BIND=<uuid>,<new_id>` | **身份绑定**。<br>将指定 UUID 设备的 NetID 修改为新 ID，并重启生效。 | `CMD:BIND=3149644322,5`<br>(将 UUID 为 ... 的设备 ID 改为 5) |
| **GROUP** | `CMD:GROUP=<new_gid>` | **修改组别**。<br>修改当前设备的 GroupID，立即生效并保存。 | `CMD:GROUP=200`<br>(将设备划入 200 组) |
| **RST** | `CMD:RST` | **远程复位**。<br>强制设备执行系统复位。 | `CMD:RST` |
| **FACTORY**| `CMD:FACTORY` | **恢复出厂**。<br>清除 Flash 配置，恢复默认参数。 | `CMD:FACTORY` |
| **CFG** | `CMD:CFG=<id>,<ch>,<pwr>` | **参数配置**。<br>同时修改 ID、信道和功率。 | `CMD:CFG=2,23,3` |

> **提示:** 您可以通过串口助手直接发送这些字符串来测试管理功能，也可以通过 `LoRa_Service_Send` 接口由另一台设备远程发送。
---
